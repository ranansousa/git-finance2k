unit LibMega;

interface

uses
  Classes, db,  Windows, Dialogs,
  EMsgDlg, SysUtils, Forms, ELibFnc,  DBCommon, DBGrids,
  stdctrls, checklst, ENumEd, RxLookup, Mask, buttons, Registry,
  EDrvBox, Messages, Controls, DBClient,  Constants,
  ExtCtrls, ComCtrls, Graphics, SqlExpr, Math, DBCtrls, EChkGrp,
  TypInfo, EDateEd, EMonthYear,  UVarGlobais,
//  {$IFDEF VER150}
//    ToolEdit, CurrEdit,
//  {$ENDIF}
//  {$ELSE}
//  {$IFDEF VER230}
   // RDprint, RxToolEdit, RxCurrEdit, System.RegularExpressions,
//  {$ENDIF}
  Util,
  {Início units do FireDac}
  FireDAC.Stan.Intf, FireDAC.Stan.Option, FireDAC.Stan.Param,
  FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf, FireDAC.DApt.Intf,
  FireDAC.Stan.Async, FireDAC.DApt, FireDAC.Comp.DataSet, FireDAC.Comp.Client;
  {Fim units do FireDac}

type
  TIntArray = array of integer;
  TStrArray = array of string;
  TFeriados = (frPascoa, frCarnaval, frQuartaCinzas, frSextaSanta, frCorpusChristi);


type
  TLibMega = class(TComponent)

  private
    { Private declarations }
  protected
    { Protected declarations }
  public
    { Public declarations }
    constructor Create(AOwner: TComponent); override;
  published
    { Published declarations }
  end;

const
  StartKey = 321; {Start default key}
  MultKey  = 1;	  {Mult default key}
  AddKey	 = 3;	  {Add default key}

procedure Register;

// Funcoes de Criação de tabelas
function CriaTblComputadores(sPath:string):Boolean;
function CriaTabControleVersao(sPath,sVersao:String): boolean;
function CriaTabTUsersIBx(sPath:String): boolean;
function CriaTabCadastro(sPath:String): boolean;
function CriaTabContabil(sPath:String): boolean;
function CriaTabFinanceiro(sPath:string): Boolean;
{Cria e preenche as tabelas do programa pessoal que serão utilizadas
pelo PPP. }
function CriaTabPessoalPPP(sPath:string): Boolean;

//Criptografia
function Encrypt(InString: String): String;
function Decrypt(InString: String): String;
function BinaryMethod(const aText: string; aKey: word): string;
function fCripto( sLinha:String ):string;
function fDeCripto( sLinha:String ):string;

{Feriados}
function CalculaPascoa(AAno: Word): TDateTime;
function CalculaFeriado(AAno: Word; ATipo: TFeriados): TDate;
function fGravaFeriados(pbAtualiza: Boolean = False): Boolean; {Grava ou atualiza a tabela com todos os feriados nacionais móveis e fixos de 1980 a 2050}
function QtdeferiadosPeriodo(pdDataI,pdDataF: TDateTime; poConn: TFDConnection;
  pbSabadoUtil: boolean): Integer;

{Datas}
function AcrescMinutos(dData:TDateTime;iMinutos:integer):TDateTime;//Acrescenta N minutos a uma dataHora
function IncDecAnos(pdData: TDateTime; piAnos:integer): TDateTime;//Incrementa ou decrementa anos a uma data (Se iAnos for positivo incrementa, negativo decrementa)
function IncDecMes(dData:TDateTime;iTempo:Integer):TDateTime; //Se positivo, incrementa mês(es). Se negativo decrementa mês(es)
{ValidaData Retorna true se a data contida no componente TDateEdit passado
por parâmetro for válida. Deve ser colocado nos eventos OnChange e OnExit do
do componente TDateEdit. Sendo que, no evento onChange, deve-se atribuir False
ao parâmetro pbOnExit}
//function ValidaData(TData: TDateEdit; pbOnExit: Boolean = True): boolean;overload;
function ValidaData(TData: TEvMonthYear; pbOnExit: Boolean = True): boolean;overload;
{ValidaDataExit Retorna true se a data contida no componente TDateEdit passado
por parâmetro for valida. Deve ser colocado no OnExit do componente TDateEdit}
//function ValidaDataExit(TData: TDateEdit): boolean;
function MesAno(dData:TDateTime;bExtenso:boolean):string; //Retorna MM/YYYY ou mês/YYYY
function InterDatas(dDt1,dDt2,dDt3,dDt4:TDate):integer;//Retorna a quantidade de dias de intersseção entre o período dDt1,dDt2 e o período dDt3 e dDt4
function MyYearsBetween(dDt1,dDt2:TDateTime):integer;//Retorna a quantidade de anos entre duas datas
function MyMonthsBetween(dData_i,dData_f:TDateTime;bPropor,bMesCalend:Boolean):Integer; // Verifica a quantidade de meses em um intervalo de datas
procedure DifDatas(dData_i,dData_f:TDateTime; var iAnos,iMeses,iDias: Integer); {Diferença entre datas}
function NroSemana(Data: TDateTime): shortint; //Retorna o nº da semana dentro do ano
function DataParaStoreProcedure(Data: TDate): String; //Retorna uma data no formato '01.01.1980' para ser inserida em um parâmetro de uma Store Procedure, em uma sentença SQL de uma query
function DateInBetween(ldData,ldData1,ldData2: TDate): Boolean; //Verifica se ldData está entre ldData1 e ldData2
function DiaUtilAnterior(pConn: TFDConnection; pdData: TDate; pbSabadoUtil: Boolean = True): TDate;
function DiaUtilPosterior(pConn: TFDConnection; pdData: TDate; pbSabadoUtil: Boolean = True): TDate;
function DataExtenso(pData: TDate): String;
function DiasUteis(pdDataI,pdDataF: TDateTime; poConn: TFDConnection; pbSabadoUtil: boolean): Integer;
function StrSemBarrasToDate(psData: String): TDate; {Recebe uma data no formato 03052011 e retorna 03/05/2011}

//Array
function aSortS(sElemento:String;aArray:Array of string):Integer;overload; //Localiza um elemento dentro de uma array string
function aSortS(sElemento:String;oStrings:TStrings):Integer;overload; //Localiza um elemento dentro de um TStrings
function aSortS(sElemento:String;oStrings:TStringList):Integer;overload; //Localiza um elemento dentro de um TStrings
function aSortI(iElemento:integer;aArray:Array of integer):Integer;//Localiza um elemento dentro de um array Integer
function aSortD(dElemento:TDateTime;aArray:Array of TDateTime):Integer;//Localiza um elemento dentro de um array DateTime

//Strings
function Stuff(sString,sInsere:string;iInicio,iElimina:integer):String;// Esta função modifica uma string (igual ao clipper)
function Valid_Caracter(psString: String; pbEliminaBranco: Boolean = False): String;//Substitue os caracteres não válidos.
function fSoNumeros(psString: String): String; {Retorna uma string somente com os números contidos em psString, ou uma string vazia se não existirem números em psString}
function InscMfCMasc(psInscMf,psTipo:string):string;//Retorna a InscMf com máscara
function SubstText(sTexto, s1, s2: string): string; //Substitue todas as ocorrências encontradas em um texto.
{Abrevia os nomes do meio. Ex: André Luis Ribeiro da Fonte, retorna Rua André L. R. da Fonte}
function AbreviaNome(sNome: String): String;
function MyCurrToStr(pdblValor: Currency; piTamanho,piDecimais: Integer;
  pbSeparadores: Boolean; pbZerosEsquerda: Boolean = true): String;
function ControleCnpj(psCnpj: String): String;
function CentraLinha(piColunaInicial,piTamLinha: Integer; psTexto: String): String; {Retorna a linha com tantos espaços em branco necessários para centralizar o texto na linha}
//procedure StringListSort(var poStringList: TStringList);
//function AddInconssistencia(var poStringList: TStringList; psTexto: string; pbLinhaBranco: Boolean): Integer; {pbLinhaBranco, quando true, adiciona uma linha em branco a stringlist}
function AddStringList(var poStringList: TStringList; psTexto: string; pbLinhaBranco: Boolean): Integer; {pbLinhaBranco, quando true, adiciona uma linha em branco a stringlist}
function UpperNome(psNome: String): String; {Retorna o nome com todas as primeiras letras em maiúlculo, exceto preposições.}
function ValidarEMail(const psEnderecoEmail: String): Boolean;

// Outros
procedure CapsLock(State: Boolean);
procedure NumLock(State: Boolean);
//function SetFileDateTime(FileName: String; NewDateTime: TDateTime): Boolean;
//function SetFileDateTime(NomeArq: string; DataHora: TDateTime): boolean;
//function LockPessimistic(DataSet:TDataSet;sPath:string;IBDataBase:TIBDataBase;IBTransaction:TIBTransaction;sTabela:string):boolean;
Procedure fCriaFormModal(FormClasse :TComponentClass; NomeForm :TForm ); //Cria e destroi um Form Modal
function fGravaRegistro(ClienteDataSet :TClientDataSet;sTipo:String;bMsg:boolean=true):boolean; //Persiste um registro gravado ou deletado

{Executa um programa e aguarda sua finalização antes de continuar
ExecAndWait com parâmetro só aceita um parâmetro e
ExecCmdLineAndWait sem parâmetro. Nesse caso, passar os parâmetros na própria
linha. Ex:
if (ExecCmdLineAndWait('D:\BD\wget.exe www.wellsoft.com.br/teste.txt -q -O D:\BD\teste.txt', SW_HIDE)) then }

function ExecAndWait(const FileName, Params: string; const WindowState: Word): boolean;
function ExecCmdLineAndWait(const CmdLine: string; WindowState: Word): Boolean;

function CheckTituloEleitor(numero: String):boolean;
procedure RdRodape(iLinha,iCol,iTamTraco:integer; psId: string = ''; pbImprimeData: Boolean = True);
procedure AtualizaStatusBar(var postBar: TStatusBar; psVersao: String; pdDataOperacao,pdDataInicio: TDate; pdAtualizaDatas: Boolean = True);
{$REGION 'BooleanToInt...'}
/// <summary>
/// Função que converte um Boolean em seu respectivo valor integer
/// </summary>
/// <param name="pbBoolean">Variável do tipo boolean</param>
/// <returns>Variável do tipo integer</returns>
/// <remarks>
///  Função mantida para retro-compatibilidade. Foi criado um Helper para o tipo
///  Boolean que implementa essa funcionalidade.
///  <c>Ex.: VarInt := VarBol.ToInteger </c>
///  <para>Changed by IJNeves 29/11/2016 16:58:06</para>
/// </remarks>
{$ENDREGION}
function BooleanToInt(pbBoolean: Boolean): Integer;
{$REGION 'IntToBoolean...'}
/// <summary>
/// Função que converte um Integer em um Boolean
/// </summary>
/// <param name="piInteger">Variável do tipo integer</param>
/// <returns>
///  Variável do tipo Boolean onde será retornado <c>True</c> para os valores
///  diferentes de 0 (zero)
/// </returns>
/// <remarks>
///  Função mantida para retro-compatibilidade. Apartir do Delphi XE3 foi implementado
///  na Unit System.SysUtils um Helper que implementa essa funcionalidade: TIntegerHelper.ToBoolean
/// </remarks>
{$ENDREGION}
function IntToBoolean(piInteger: Integer): Boolean;
function fEnderecoPessoa(poCdsPessoa: TClientDataSet; pTamanhoLinha: Integer): String;
procedure OrdenaDataSetGrid(var CDS: TClientDataSet; Column: TColumn; var dbgPrin: TDBGrid); {Chamar essa função no evento ontitleclick do dbgrid. Ela ordena o dbgrid ao clicar na coluna.}
function IsInternetConected(): Boolean; {VErifica se está conectado a Internet}

function EnumResTypes(hMod: THandle; ResType, ResName: PChar; Lines: TStrings):BOOL; Stdcall;
function fContaMask(sEstrutura:String):string;
Procedure MegaContabilContaGrau(psConta,psEstruturaPlano: String;
  var poStrLstResult: TStringList);



//Forms e Edits
Procedure fHabilita(Form: TForm);
Procedure fDesabilita(Form: TForm);
Procedure LimpaEdits(Form: TForm; pbSoInabilitados: Boolean = False);
Procedure fPassaCampo(Sender: TObject; var key:Word);
{MakeRounded Função que faz os componentes descendentes do TWinControl terem seus cantos
  arredondados.}
procedure MakeRounded(Control: TWinControl);

{Funções matemáticas}
function Arredondar(pdblValor: Double; qtdeDecimais: Integer): Double;
function DecimalToRomano( piDecimal: LongInt ): String;
function IncValue(var value: Integer; piIncremento: Integer = 1): Integer;
function IncLongWord(var value: LongWord): LongWord;

implementation

// Create
constructor TLibMega.Create(AOwner: TComponent);
const
  bShareware: Boolean = False;
begin
  inherited Create(AOwner);
  // mensagem shareware
  if bShareware and not (csDesigning in ComponentState) then
    begin
      MessageBeep(MB_ICONASTERISK);
      MessageDlg('   O componente ' + ClassName + ' é shareware, e para ' +
        'utiliza-lo livremente' + #9#13 + '   você deve registra-lo.' + #13#13 +
        '    http://www.megasoftware.com.br' + #13 +
        '    mailto:megasoft@megasoftware.com.br', mtInformation, [mbOk], 0);
//      bShareware := False;
    end;
end;

//Register
procedure Register;
begin
  RegisterComponents('Megasoft', [TLibMega]);
end;

function Arredondar(pdblValor: Double; qtdeDecimais: Integer): Double;
Var
  ldblFracao, ldblTotal: Real;
  lsDecimal: String;
  liDecimal: Integer;
begin
//  try
    ldblFracao := Frac(pdblValor); {Retorna a parte fracionária de um número}
    lsDecimal := StrRight(FloatToStr(ldblFracao),length(FloatToStr(ldblFracao))-2); {decimal recebe a parte decimal}
    {Enquanto o tamanho da variavel decimal for maior que o número de casas faça}
    while Length(lsDecimal) > qtdeDecimais do begin
      {Verifica se o último digito da variável decimal é maior que 5}
      liDecimal := 0;
      TryStrToInt(StrRight(lsDecimal,1),liDecimal);
//      if StrToInt(StrRight(lsDecimal,1))>5 then begin
      if (liDecimal > 5) then begin
        {Descarta o último digito da variável Decimal}
        lsDecimal := StrLeft(lsDecimal,length(lsDecimal)-1);
        {Soma o valor número da variavel decimal + 1}
        lsDecimal := FloatToStr(StrToFloat(lsDecimal) + 1);
      end else begin
        lsDecimal := StrLeft(lsDecimal,Length(lsDecimal)-1); //Descarta o último digito da variável Decimal
      end;
    end;
    result := (Int(pdblValor) + (StrToFloat(lsDecimal)/100)); //devolve o resultado para a função
//  except
//    Raise Exception.Create('Erro no arredondamento');
//  end;
end;

{Ver como funciona essa função}
//function Arredondar(Valor: Double; Dec: Integer): Double;
//var
//Valor1,
//Numero1,
//Numero2,
//Numero3: Double;
//begin
//Valor1:=Exp(Ln(10) * (Dec + 1));
//Numero1:=Int(Valor * Valor1);
//Numero2:=(Numero1 / 10);
//Numero3:=Round(Numero2);
//Result:=(Numero3 / (Exp(Ln(10) * Dec)));
//end;


Procedure MegaContabilContaGrau(psConta,psEstruturaPlano: String;
  var poStrLstResult: TStringList);
var
  lsConta: String;
  liTamanhoConta: SmallInt;
begin
  lsConta        := fSoNumeros(psConta);
  liTamanhoConta := Length(lsConta);
  poStrLstResult.Clear;
  poStrLstResult.Add('CONTA_MASCARA='+psConta);
  poStrLstResult.Add('CONTA='+lsConta);
  poStrLstResult.Add('CONTA_ANTERIOR=');
  poStrLstResult.Add('GRAU=0');
  poStrLstResult.Add('GRAU_MAXIMO=5');
  poStrLstResult.Add('TAMANHO_CONTA='+IntToStr(liTamanhoConta));

  if (psEstruturaPlano = '9.9.9.99.999')
    or (psEstruturaPlano = '9.9.9.99.9999')
    or (psEstruturaPlano = '9.9.9.99.99999')
  then begin
    poStrLstResult.Add('GRAU1='+Copy(psConta,1,1));
    poStrLstResult.Add('GRAU2='+Copy(psConta,1,3));
    poStrLstResult.Add('GRAU3='+Copy(psConta,1,5));
    poStrLstResult.Add('GRAU4='+Copy(psConta,1,8));
    poStrLstResult.Add('GRAU5='+Copy(psConta,1,liTamanhoConta));

    if liTamanhoConta = 1 then begin
      poStrLstResult.Strings[0] := 'CONTA_MASCARA=' +Copy(psConta,1,1);
      poStrLstResult.Strings[2] := 'CONTA_ANTERIOR=';
      poStrLstResult.Strings[3] := 'GRAU=1';
    end else if liTamanhoConta = 2 then begin
      poStrLstResult.Strings[0] := 'CONTA_MASCARA=' +Copy(psConta,1,3);
      poStrLstResult.Strings[2] := 'CONTA_ANTERIOR='+Copy(psConta,1,1);
      poStrLstResult.Strings[3] := 'GRAU=2';
    end else if liTamanhoConta = 3 then begin
      poStrLstResult.Strings[0] := 'CONTA_MASCARA=' +Copy(psConta,1,5);
      poStrLstResult.Strings[2] := 'CONTA_ANTERIOR='+Copy(psConta,1,3);
      poStrLstResult.Strings[3] := 'GRAU=3';
    end else if liTamanhoConta = 5 then begin
      poStrLstResult.Strings[0] := 'CONTA_MASCARA=' +Copy(psConta,1,8);
      poStrLstResult.Strings[2] := 'CONTA_ANTERIOR='+Copy(psConta,1,5);
      poStrLstResult.Strings[3] := 'GRAU=4';
    end else if liTamanhoConta <= 10 then begin
      poStrLstResult.Strings[0] := 'CONTA_MASCARA=' +Copy(psConta,1,liTamanhoConta);
      poStrLstResult.Strings[2] := 'CONTA_ANTERIOR='+Copy(psConta,1,8);
      poStrLstResult.Strings[3] := 'GRAU=5';
    end else begin
      poStrLstResult.Strings[0] := 'CONTA_MASCARA=';
      poStrLstResult.Strings[2] := 'CONTA_ANTERIOR=';
      poStrLstResult.Strings[3] := 'GRAU=0';
    end;
  end else if psEstruturaPlano = '9.9.9.99.99.99' then begin {Partidos Políticos}
    poStrLstResult.Add('GRAU_MAXIMO=6');
    poStrLstResult.Add('GRAU1='+Copy(psConta,1,1));
    poStrLstResult.Add('GRAU2='+Copy(psConta,1,3));
    poStrLstResult.Add('GRAU3='+Copy(psConta,1,5));
    poStrLstResult.Add('GRAU4='+Copy(psConta,1,8));
    poStrLstResult.Add('GRAU5='+Copy(psConta,1,11));
    poStrLstResult.Add('GRAU5='+Copy(psConta,1,liTamanhoConta));
    if liTamanhoConta = 1 then begin
      poStrLstResult.Strings[0] := 'CONTA_MASCARA=' +Copy(psConta,1,1);
      poStrLstResult.Strings[2] := 'CONTA_ANTERIOR=';
      poStrLstResult.Strings[3] := 'GRAU=1';
    end else if liTamanhoConta = 2 then begin
      poStrLstResult.Strings[0] := 'CONTA_MASCARA=' +Copy(psConta,1,3);
      poStrLstResult.Strings[2] := 'CONTA_ANTERIOR='+Copy(psConta,1,1);
      poStrLstResult.Strings[3] := 'GRAU=2';
    end else if liTamanhoConta = 3 then begin
      poStrLstResult.Strings[0] := 'CONTA_MASCARA=' +Copy(psConta,1,5);
      poStrLstResult.Strings[2] := 'CONTA_ANTERIOR='+Copy(psConta,1,3);
      poStrLstResult.Strings[3] := 'GRAU=3';
    end else if liTamanhoConta = 5 then begin
      poStrLstResult.Strings[0] := 'CONTA_MASCARA=' +Copy(psConta,1,8);
      poStrLstResult.Strings[2] := 'CONTA_ANTERIOR='+Copy(psConta,1,5);
      poStrLstResult.Strings[3] := 'GRAU=4';
    end else if liTamanhoConta = 7 then begin
      poStrLstResult.Strings[0] := 'CONTA_MASCARA=' +Copy(psConta,1,11);
      poStrLstResult.Strings[2] := 'CONTA_ANTERIOR='+Copy(psConta,1,8);
      poStrLstResult.Strings[3] := 'GRAU=5';
    end else if liTamanhoConta = 9 then begin
      poStrLstResult.Strings[0] := 'CONTA_MASCARA=' +Copy(psConta,1,liTamanhoConta);
      poStrLstResult.Strings[2] := 'CONTA_ANTERIOR='+Copy(psConta,1,11);
      poStrLstResult.Strings[3] := 'GRAU=6';
    end else begin
      poStrLstResult.Strings[0] := 'CONTA_MASCARA=';
      poStrLstResult.Strings[2] := 'CONTA_ANTERIOR=';
      poStrLstResult.Strings[3] := 'GRAU=0';
    end;
//  end else if psEstruturaPlano = '9.9.9.9.99.99999' then begin {EBDA}
//    FContabil.iGrauMax := 6;
//    FContabil.sConta := fSoNumeros(sConta);
//    liTamanhoConta := Length(FContabil.sConta);
//    FContabil.sGrau1 := Trim(Copy(sConta,1,1));
//    FContabil.sGrau2 := Trim(Copy(sConta,1,3));
//    FContabil.sGrau3 := Trim(Copy(sConta,1,5));
//    FContabil.sGrau4 := Trim(Copy(sConta,1,7));
//    FContabil.sGrau5 := Trim(Copy(sConta,1,10));
//    FContabil.sGrau6 := Trim(Copy(sConta,1,16));
//    if liTamanhoConta = 1 then begin
//      FContabil.iGrau := 1;
//      FContabil.sContaAnt  := '';
//      FContabil.sContaMasc := Copy(sConta,1,1);
//    end else if liTamanhoConta = 2 then begin
//      FContabil.iGrau := 2;
//      FContabil.sContaAnt  := Copy(sConta,1,1);
//      FContabil.sContaMasc := Copy(sConta,1,3);
//    end else if liTamanhoConta = 3 then begin
//      FContabil.iGrau := 3;
//      FContabil.sContaAnt  := Copy(sConta,1,3);
//      FContabil.sContaMasc := Copy(sConta,1,5);
//    end else if liTamanhoConta = 4 then begin
//      FContabil.iGrau := 4;
//      FContabil.sContaAnt  := Copy(sConta,1,5);
//      FContabil.sContaMasc := Copy(sConta,1,7);
//    end else if liTamanhoConta = 6 then begin
//      FContabil.iGrau := 5;
//      FContabil.sContaAnt  := Copy(sConta,1,7);
//      FContabil.sContaMasc := Copy(sConta,1,10);
//    end else if liTamanhoConta = 11 then begin
//      FContabil.iGrau := 6;
//      FContabil.sContaAnt  := Copy(sConta,1,10);
//      FContabil.sContaMasc := Copy(sConta,1,16);
//    end else begin
//      FContabil.iGrau := 0;
//      FContabil.sContaAnt  := '';
//      FContabil.sContaMasc := '';
//    end;
//  end else if psEstruturaPlano = '9.9.9.999.999' then begin
//    FContabil.sConta := Trim(Copy(sConta,1,1) + Copy(sConta,3,1) + Copy(sConta,5,1) + Copy(sConta,7,3) + Copy(sConta,11,3));
//    liTamanhoConta := Length(FContabil.sConta);
//    FContabil.sGrau1 := Trim(Copy(sConta,1,1));
//    FContabil.sGrau2 := Trim(Copy(sConta,1,3));
//    FContabil.sGrau3 := Trim(Copy(sConta,1,5));
//    FContabil.sGrau4 := Trim(Copy(sConta,1,9));
//    FContabil.sGrau5 := Trim(Copy(sConta,1,13));
//    if liTamanhoConta = 1 then begin
//      FContabil.iGrau := 1;
//      FContabil.sContaAnt  := '';
//      FContabil.sContaMasc := Copy(sConta,1,1);
//    end else if liTamanhoConta = 2 then begin
//      FContabil.iGrau := 2;
//      FContabil.sContaAnt  := Copy(sConta,1,1);
//      FContabil.sContaMasc := Copy(sConta,1,3);
//    end else if liTamanhoConta = 3 then begin
//      FContabil.iGrau := 3;
//      FContabil.sContaAnt  := Copy(sConta,1,3);
//      FContabil.sContaMasc := Copy(sConta,1,5);
//    end else if liTamanhoConta = 6 then begin
//      FContabil.iGrau := 4;
//      FContabil.sContaAnt  := Copy(sConta,1,5);
//      FContabil.sContaMasc := Copy(sConta,1,9);
//    end else if liTamanhoConta = 9 then begin
//      FContabil.iGrau := 5;
//      FContabil.sContaAnt  := Copy(sConta,1,9);
//      FContabil.sContaMasc := Copy(sConta,1,13);
//    end else begin
//      FContabil.iGrau := 0;
//      FContabil.sContaAnt  := '';
//      FContabil.sContaMasc := '';
//    end;
//  end else if psEstruturaPlano = '9.9.9.999.9999' then begin
//    FContabil.sConta := Trim(Copy(sConta,1,1) + Copy(sConta,3,1) + Copy(sConta,5,1) + Copy(sConta,7,3) + Copy(sConta,11,4));
//    liTamanhoConta := Length(FContabil.sConta);
//    FContabil.sGrau1 := Trim(Copy(sConta,1,1));
//    FContabil.sGrau2 := Trim(Copy(sConta,1,3));
//    FContabil.sGrau3 := Trim(Copy(sConta,1,5));
//    FContabil.sGrau4 := Trim(Copy(sConta,1,9));
//    FContabil.sGrau5 := Trim(Copy(sConta,1,14));
//    if liTamanhoConta = 1 then begin
//      FContabil.iGrau := 1;
//      FContabil.sContaAnt  := '';
//      FContabil.sContaMasc := Copy(sConta,1,1);
//    end else if liTamanhoConta = 2 then begin
//      FContabil.iGrau := 2;
//      FContabil.sContaAnt  := Copy(sConta,1,1);
//      FContabil.sContaMasc := Copy(sConta,1,3);
//    end else if liTamanhoConta = 3 then begin
//      FContabil.iGrau := 3;
//      FContabil.sContaAnt  := Copy(sConta,1,3);
//      FContabil.sContaMasc := Copy(sConta,1,5);
//    end else if liTamanhoConta = 6 then begin
//      FContabil.iGrau := 4;
//      FContabil.sContaAnt  := Copy(sConta,1,5);
//      FContabil.sContaMasc := Copy(sConta,1,9);
//    end else if liTamanhoConta = 10 then begin
//      FContabil.iGrau := 5;
//      FContabil.sContaAnt  := Copy(sConta,1,9);
//      FContabil.sContaMasc := Copy(sConta,1,14);
//    end else begin
//      FContabil.iGrau := 0;
//      FContabil.sContaAnt  := '';
//      FContabil.sContaMasc := '';
//    end;
//  end else if (psEstruturaPlano = '9.9.9.9.99.99')
////    or (sEstrutura = '9.9.9.9.99.99999') {EBDA}
//  then begin
//    FContabil.iGrauMax := 6;
//    if (psEstruturaPlano = '9.9.9.9.99.99') then begin
//      FContabil.sConta := Trim(Copy(sConta,1,1)+Copy(sConta,3,1)+Copy(sConta,5,1)+Copy(sConta,7,1)+Copy(sConta,9,2)+Copy(sConta,11,2));
//    end else begin
//      FContabil.sConta := Trim(Copy(sConta,1,1)+Copy(sConta,3,1)+Copy(sConta,5,1)+Copy(sConta,7,1)+Copy(sConta,9,2)+Copy(sConta,11,5));
//    end;
//    liTamanhoConta := Length(FContabil.sConta);
//    FContabil.sGrau1 := Trim(Copy(sConta,1,1));
//    FContabil.sGrau2 := Trim(Copy(sConta,1,3));
//    FContabil.sGrau3 := Trim(Copy(sConta,1,5));
//    FContabil.sGrau4 := Trim(Copy(sConta,1,7));
//    FContabil.sGrau5 := Trim(Copy(sConta,1,10));
//    if (psEstruturaPlano = '9.9.9.9.99.99') then begin
//      FContabil.sGrau6 := Trim(Copy(sConta,1,13));
//    end else begin
//      FContabil.sGrau6 := Trim(Copy(sConta,1,16));
//    end;
//    if liTamanhoConta = 1 then begin
//      FContabil.iGrau := 1;
//      FContabil.sContaAnt  := '';
//      FContabil.sContaMasc := Copy(sConta,1,1);
//    end else if liTamanhoConta = 2 then begin
//      FContabil.iGrau := 2;
//      FContabil.sContaAnt  := Copy(sConta,1,1);
//      FContabil.sContaMasc := Copy(sConta,1,3);
//    end else if liTamanhoConta = 3 then begin
//      FContabil.iGrau := 3;
//      FContabil.sContaAnt  := Copy(sConta,1,3);
//      FContabil.sContaMasc := Copy(sConta,1,5);
//    end else if liTamanhoConta = 4 then begin
//      FContabil.iGrau := 4;
//      FContabil.sContaAnt  := Copy(sConta,1,5);
//      FContabil.sContaMasc := Copy(sConta,1,7);
//    end else if liTamanhoConta = 5 then begin
//      FContabil.iGrau := 5;
//      FContabil.sContaAnt  := Copy(sConta,1,7);
//      FContabil.sContaMasc := Copy(sConta,1,9);
//    end else if liTamanhoConta = 7 then begin
//      FContabil.iGrau := 6;
//      if (psEstruturaPlano = '9.9.9.9.99.99') then begin
//        FContabil.sContaAnt  := Copy(sConta,1,10);
//        FContabil.sContaMasc := Copy(sConta,1,13);
//      end else begin
//        FContabil.sContaAnt  := Copy(sConta,1,10);
//        FContabil.sContaMasc := Copy(sConta,1,16);
//      end;
//    end else begin
//      FContabil.iGrau := 0;
//      FContabil.sContaAnt  := '';
//      FContabil.sContaMasc := '';
//    end;
//  end else if psEstruturaPlano = '9.9.9.9.99999.9999' then begin
//    FContabil.iGrauMax := 6;
//    FContabil.sConta := fSoNumeros(sConta);
//    liTamanhoConta := Length(FContabil.sConta);
//    FContabil.sGrau1 := Trim(Copy(sConta,1,1));
//    FContabil.sGrau2 := Trim(Copy(sConta,1,3));
//    FContabil.sGrau3 := Trim(Copy(sConta,1,5));
//    FContabil.sGrau4 := Trim(Copy(sConta,1,7));
//    FContabil.sGrau5 := Trim(Copy(sConta,1,13));
//    FContabil.sGrau6 := Trim(Copy(sConta,1,18));
//    if liTamanhoConta = 1 then begin
//      FContabil.iGrau := 1;
//      FContabil.sContaAnt  := '';
//      FContabil.sContaMasc := Copy(sConta,1,1);
//    end else if liTamanhoConta = 2 then begin
//      FContabil.iGrau := 2;
//      FContabil.sContaAnt  := Copy(sConta,1,1);
//      FContabil.sContaMasc := Copy(sConta,1,3);
//    end else if liTamanhoConta = 3 then begin
//      FContabil.iGrau := 3;
//      FContabil.sContaAnt  := Copy(sConta,1,3);
//      FContabil.sContaMasc := Copy(sConta,1,5);
//    end else if liTamanhoConta = 4 then begin
//      FContabil.iGrau := 4;
//      FContabil.sContaAnt  := Copy(sConta,1,5);
//      FContabil.sContaMasc := Copy(sConta,1,7);
//    end else if liTamanhoConta = 9 then begin
//      FContabil.iGrau := 5;
//      FContabil.sContaAnt  := Copy(sConta,1,7);
//      FContabil.sContaMasc := Copy(sConta,1,13);
//    end else if liTamanhoConta = 13 then begin
//      FContabil.iGrau := 6;
//      FContabil.sContaAnt  := Copy(sConta,1,13);
//      FContabil.sContaMasc := Copy(sConta,1,18);
//    end else begin
//      FContabil.iGrau := 0;
//      FContabil.sContaAnt  := '';
//      FContabil.sContaMasc := '';
//    end;
//  end else if psEstruturaPlano = '9.9.9.99.99.99.99' then begin
//    FContabil.iGrauMax := 7;
////    FContabil.sConta := Trim(Copy(sConta,1,1)+Copy(sConta,3,1)+Copy(sConta,5,1)+Copy(sConta,7,1)+Copy(sConta,9,1)+Copy(sConta,11,2));
//    FContabil.sConta := FSoNumeros(sConta);
//    liTamanhoConta := Length(FContabil.sConta);
//    FContabil.sGrau1 := Trim(Copy(sConta,1,1));
//    FContabil.sGrau2 := Trim(Copy(sConta,1,3));
//    FContabil.sGrau3 := Trim(Copy(sConta,1,5));
//    FContabil.sGrau4 := Trim(Copy(sConta,1,8));
//    FContabil.sGrau5 := Trim(Copy(sConta,1,11));
//    FContabil.sGrau6 := Trim(Copy(sConta,1,14));
//    FContabil.sGrau7 := Trim(Copy(sConta,1,17));
//    if liTamanhoConta = 1 then begin
//      FContabil.iGrau := 1;
//      FContabil.sContaAnt  := '';
//      FContabil.sContaMasc := Copy(sConta,1,1);
//    end else if liTamanhoConta = 2 then begin
//      FContabil.iGrau := 2;
//      FContabil.sContaAnt  := Copy(sConta,1,1);
//      FContabil.sContaMasc := Copy(sConta,1,3);
//    end else if liTamanhoConta = 3 then begin
//      FContabil.iGrau := 3;
//      FContabil.sContaAnt  := Copy(sConta,1,3);
//      FContabil.sContaMasc := Copy(sConta,1,5);
//    end else if liTamanhoConta = 5 then begin
//      FContabil.iGrau := 4;
//      FContabil.sContaAnt  := Copy(sConta,1,5);
//      FContabil.sContaMasc := Copy(sConta,1,8);
//    end else if liTamanhoConta = 7 then begin
//      FContabil.iGrau := 5;
//      FContabil.sContaAnt  := Copy(sConta,1,8);
//      FContabil.sContaMasc := Copy(sConta,1,11);
//    end else if liTamanhoConta = 9 then begin
//      FContabil.iGrau := 6;
//      FContabil.sContaAnt  := Copy(sConta,1,11);
//      FContabil.sContaMasc := Copy(sConta,1,14);
//    end else if liTamanhoConta = 11 then begin
//      FContabil.iGrau := 7;
//      FContabil.sContaAnt  := Copy(sConta,1,14);
//      FContabil.sContaMasc := Copy(sConta,1,17);
//    end else begin
//      FContabil.iGrau := 0;
//      FContabil.sContaAnt  := '';
//      FContabil.sContaMasc := '';
//    end;
//  end else begin
//    FContabil.MsgDlg1.Text := 'É necessário definir a estrutura do plano ' + sGerEmp + '|em Plano de Contas/Estrutura do Plano de Contas';
//    FContabil.MsgDlg1.Execute;
//    Result := false;
  end else begin
    ShowMessage('Reporte esse erro a Wellsoft: Método MegaContabilContaGrau - LibMega.');
    Application.Terminate;
  end;
end;




function EnumResTypes(hMod: THandle; ResType, ResName: PChar; Lines: TStrings):
  BOOL; Stdcall;
var
  MS: TMemoryStream;
  RS: TResourceStream;
  tmp,S, S2, sFormName, sCaption, sCompName, sClasse : string;
  i: Integer;
  Temp  : TStrings;
  iCont, iLin : integer;
  bTbSheet : boolean;
begin
  Result := True;
  bTbSheet := false;
  if Assigned(ResName) then begin
    Temp := TStringList.Create;
    RS := TResourceStream.Create(hinstance, ResName, ResType);
    try
      try
        MS := TMemoryStream.Create;
        try
          ObjectBinaryToText(RS, MS);
          SetLength(S, MS.Size);
          MS.Position := 0;
          MS.Read(S[1], MS.Size);
          if Pos('object', S) > 0 then begin
            Temp.Text := S;
            iLin := 0;
            for i := 0 to Temp.Count do begin
              S := Temp.Strings[i];
              if (Pos('TRDPRINT', UpperCase(S)) > 0) then begin
                Lines.add('  btnImprimir: '+'Imprimir');
                Lines.add('  btnPreview: '+'Preview');
                Continue;
              end;
              if (Pos('TDM', UpperCase(S)) > 0) or
                 (Pos('LOGIN', UpperCase(S)) > 0) or
                 (Pos('DFMPREVI', UpperCase(S)) > 0) or
                 (Pos('DFMPROGR', UpperCase(S)) > 0) or
                 (Pos('DFMSETUP', UpperCase(S)) > 0) or
                 (Pos('CALCULADORA', UpperCase(S)) > 0) or
                 (Pos('DIALOG', UpperCase(S)) > 0) then begin
                Break;
              end;
              if (i = 0) or (Pos('TBUTTON', UpperCase(S)) > 0) or (Pos('TSPEEDBUTTON', UpperCase(S)) > 0) or (Pos('TBITBTN', UpperCase(S)) > 0) or (Pos('TABSHEET', UpperCase(S)) > 0) then begin
                if (Pos('TABSHEET', UpperCase(S)) > 0) then begin
                  bTbSheet := true;
                end;
                for iCont := i+1 to Temp.Count do begin
                  S := Temp.Strings[iCont];
                  if (Pos('CALCULADORA', UpperCase(S)) > 0) then begin
                    Break;
                  end;
                  if (Pos('TABSHEET', UpperCase(S)) > 0) then begin
                    bTbSheet := true;
                  end;
                  if Pos('Caption', S) > 0 then begin
                    sCaption := Copy(S, Pos('=', S)+3, (length(S) - (Pos('=', S)+3)));
                    sCaption := StrSubst(sCaption,'&','',0);
                    sCaption := StrSubst(sCaption,quotedStr('#231'),'ç',0);
                    sCaption := StrSubst(sCaption,quotedStr('#227'),'ã',0);
                    sCaption := StrSubst(sCaption,quotedStr('#234'),'ê',0);
                    sCaption := StrSubst(sCaption,quotedStr('#231#227'),'çã',0);
                    if (i = 0) or (bTbSheet) then begin
                      Lines.add(sCaption);
                      bTbSheet := false;
                    end else begin
                      Lines.add(' '+sCaption);
                    end;
                    Break;
                  end;
                end;
              end;
            end;
          end;
        finally
          MS.Free
        end;
      except
        //
      end;
    finally
      RS.Free;
    end;
  end;
end;

function CriaTblComputadores(sPath:string):Boolean;
//var
//  qry : TIBQuery;
//  Tbl : TIBTable;
//  IBDataBase : TIBDataBase;
//  IBTransaction : TIBTransaction;
//  lCriouTabela : boolean;
begin
//  lCriouTabela := false;
//  result := true;
//  IBDataBase := TIBDataBase.Create(nil);
//  IBTransaction := TIBTransaction.Create(nil);
//  IBTransaction.DefaultDatabase := IBDataBase;
//  IBTransaction.Params.Add('read_committed');
//  IBTransaction.Params.Add('rec_version');
//  IBTransaction.Params.Add('nowait');
//  IBDataBase.DefaultTransaction := IBTransaction;
//  IBDataBase.AllowStreamedConnected := false;
//  IBDataBase.Connected := false;
//  IBDataBase.DatabaseName := sPath;
//  IBDataBase.DefaultTransaction := IBTransaction;
//  IBDataBase.LoginPrompt := false;
//  IBDataBase.Params.Clear;
//  IBDataBase.Params.Add( 'user_name=SYSDBA' );
//  IBDataBase.Params.Add( 'password=masterkey' );
//  IBDataBase.SQLDialect := 3;
//  try
//    try
//      IBDataBase.Connected := true;
//    except
//      result := false;
//      Exit;
//      {
//      IBDataBase.Params.Clear;
//      IBDataBase.Params.Add( 'USER "SYSDBA"' );
//      IBDataBase.Params.Add( 'PASSWORD "masterkey"' );
//      try
//        IBDataBase.CreateDatabase;
//        IBDataBase.Connected := true;
//      except
//        Result := false;
//        Exit;
//      end;
//      }
//    end;
//    Tbl := TIBTable.Create(nil);
//    Tbl.Database := IBDataBase;
//    qry := TIBQuery.Create(nil);
//    qry.Database := IBDataBase;
//
//  // Cria tabela de computadores
//    Tbl.TableName := 'COMPUTADORES';
//    if Tbl.Exists then begin
//      qry.close;
//      qry.SQL.clear;
//      qry.SQL.Add( 'SELECT * FROM '+Tbl.TableName);
//      qry.Open;
//      if qry.FieldDefs.IndexOf( 'INSCMF' ) < 0 then begin
//        qry.close;
//        qry.SQL.clear;
//        qry.SQL.Add( 'DROP TABLE '+Tbl.TableName);
//        qry.ExecSQL;
//        IBTransaction.CommitRetaining;
//      end;
//    end;
//    if not Tbl.Exists then begin
//      qry.close;
//      qry.SQL.clear;
//      qry.SQL.Add( 'CREATE TABLE ' + Tbl.TableName + ' (IDENTIFICACAO VARCHAR(100) NOT NULL, PROGRAMA VARCHAR(20) NOT NULL, INSCMF VARCHAR(18) NOT NULL, CONSTRAINT PK_'+tbl.TableName+' PRIMARY KEY (IDENTIFICACAO, PROGRAMA, INSCMF))');
//      try
//        qry.ExecSQL;
//        qry.close;
//        qry.SQL.clear;
//        try
//          qry.close;
//          qry.SQL.clear;
//          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD NOME VARCHAR(50), ADD ESTACAO VARCHAR(20), ADD USUARIO VARCHAR(20), ADD BACKUP CHAR(1), ADD HORA_FINAL TIMESTAMP' );
//          qry.ExecSQL;
//          qry.close;
//          qry.SQL.clear;
//          lCriouTabela := true;
//        except
//          begin
//            result := false;
//          end;
//        end;
//      except
//        begin
//          result := false;
//        end;
//      end;
//    end;
//    if lCriouTabela then begin
//      IBTransaction.CommitRetaining;
//    end;
//    Qry.Close;
//    Qry.Free;
//    Tbl.Close;
//    Tbl.Free;
//  finally
//    IBDataBase.Connected := false;
//    IBTransaction.Active := false;
//    IBDataBase.Free;
//    IBTransaction.Free;
//  end;
end;

 {
function CriaTabControleVersao(sPath,sVersao:String): boolean;
var
  qry : TIBQuery;
  Tbl : TIBTable;
  IBDataBase : TIBDataBase;
  IBTransaction : TIBTransaction;
  lCriouTabela : boolean;
  sPrograma, sEstacao : string;
  dData : TDateTime;
  MsgDlg1 : TEvMsgDlg;
begin
  lCriouTabela := false;
  result := true;
  IBDataBase := TIBDataBase.Create(nil);
  IBTransaction := TIBTransaction.Create(nil);
  IBTransaction.DefaultDatabase := IBDataBase;
  IBTransaction.Params.Add('read_committed');
  IBTransaction.Params.Add('rec_version');
  IBTransaction.Params.Add('nowait');
  IBDataBase.DefaultTransaction := IBTransaction;
  IBDataBase.AllowStreamedConnected := false;
  IBDataBase.Connected := false;
  IBDataBase.DatabaseName := sPath;
  IBDataBase.DefaultTransaction := IBTransaction;
  IBDataBase.LoginPrompt := false;
  IBDataBase.Params.Clear;
  IBDataBase.Params.Add( 'user_name=SYSDBA' );
  IBDataBase.Params.Add( 'password=masterkey' );
  IBDataBase.SQLDialect := 3;
  try
    try
      IBDataBase.Connected := true;
    except
       Result := false;
       Exit;
      {
      IBDataBase.Params.Clear;
      IBDataBase.Params.Add( 'USER "SYSDBA"' );
      IBDataBase.Params.Add( 'PASSWORD "masterkey"' );
      try
        IBDataBase.CreateDatabase;
        IBDataBase.Connected := true;
      except
        Result := false;
        Exit;
      end;

    end;
    Tbl := TIBTable.Create(nil);
    Tbl.Database := IBDataBase;
    qry := TIBQuery.Create(nil);
    qry.Database := IBDataBase;

  // Cria tabela de cadastro das empresas
    Tbl.TableName := 'CONTROLE_VERSAO';
    if not Tbl.Exists then begin
      qry.close;
      qry.SQL.clear;
      qry.SQL.Add( 'CREATE TABLE ' + Tbl.TableName + ' (PROGRAMA VARCHAR(20) NOT NULL, CONSTRAINT PK_'+tbl.TableName+' PRIMARY KEY (PROGRAMA))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD DATA TIMESTAMP, ADD VERSAO VARCHAR(15), ADD ESTACAO VARCHAR(30)' );
          qry.ExecSQL;
          qry.SQL.clear;
          lCriouTabela := true;
        except
          begin
  //Todo -cPrioridade -oRoberto: Caso der erro no processo de criação verificar se a tabela foi criada e destruí-la
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end;
  //Este Commit grava fisicamente as tabelas criadas.
    if lCriouTabela then begin
      IBTransaction.CommitRetaining;
    end;
    sPrograma := UpperCase(ChangeFileExt(ExtractFileName(Application.ExeName),''));
    if sPrograma <> 'AT' then begin
      dData := FileDateToDateTime(FileAge(Application.ExeName));
      sEstacao := GetCompName;
      qry.close;
      qry.SQL.clear;
      Qry.CachedUpdates := false;
      Qry.SQL.Add('SELECT * FROM CONTROLE_VERSAO WHERE PROGRAMA = :pPrograma');
      Qry.ParamByName('pPrograma').AsString := sPrograma;
      Qry.Open;
      if Qry.IsEmpty then begin
        Qry.Close;
        Qry.SQL.Clear;
        Qry.SQL.Add('INSERT INTO CONTROLE_VERSAO(PROGRAMA,DATA,VERSAO,ESTACAO) values(:pPrograma, :pData, :pVersao, :pEstacao)');
        Qry.ParamByName('pPrograma').AsString := sPrograma;
        Qry.ParamByName('pData').AsDateTime := dData;
        Qry.ParamByName('pVersao').AsString := sVersao;
        Qry.ParamByName('pEstacao').AsString := sEstacao;
        Qry.ExecSQL;
      end else if dData > Qry.FieldByName('DATA').AsDateTime then begin
        Qry.Close;
        Qry.SQL.Clear;
        Qry.SQL.Add('UPDATE CONTROLE_VERSAO SET DATA = :pData, VERSAO = :pVersao, ESTACAO = :pEstacao WHERE PROGRAMA = :pPrograma');
        Qry.ParamByName('pPrograma').AsString := sPrograma;
        Qry.ParamByName('pData').AsDateTime := dData;
        Qry.ParamByName('pVersao').AsString := sVersao;
        Qry.ParamByName('pEstacao').AsString := sEstacao;
        Qry.ExecSQL;
      end else if dData < Qry.FieldByName('DATA').AsDateTime then begin
        MsgDlg1 := TEvMsgDlg.Create(nil);
        MsgDlg1.MessageType := mtWarning;
        MsgDlg1.Style := msCenter;
        MsgDlg1.LineSeparator := '|';
        MsgDlg1.Text := 'Você esta utilizando uma versão desatualizada. |A estação '+Qry.FieldByName('ESTACAO').AsString+' esta utilizando a versão '+Qry.FieldByName('VERSAO').AsString+' de '+DateTimeToStr(Qry.FieldByName('DATA').AsDateTime)+'|e a sua versão é '+sVersao+' de '+DateTimeToStr(dData);
        MsgDlg1.Buttons := [mbOk];
        MsgDlg1.Execute;
        MsgDlg1.Free;
        Application.Terminate;
        Result := false;
      end;
      IBTransaction.CommitRetaining;
    end;
    Qry.Close;
    Qry.Free;
    Tbl.Close;
    Tbl.Free;
  finally
    IBDataBase.Connected := false;
    IBTransaction.Active := false;
    IBDataBase.Free;
    IBTransaction.Free;
  end;
end;


// Cria tabelas do TUsersIBx
function CriaTabTUsersIBx(sPath:string): Boolean;
const
// table UCS_APP_INFO
  appInfoSQL = 'CREATE TABLE UCS_APP_INFO (APP_KEY VARCHAR(20) NOT NULL,'+
               'TIME_OUT FLOAT,'+
               'MAX_BAD_LOGINS FLOAT,'+
               'MAX_DAYS_INNATIVE FLOAT,'+
               'DISABLE_USER VARCHAR(1),'+
               'MAX_PWD_HISTORY FLOAT,'+
               'ALLOW_MULTIPLE_LOGINS VARCHAR(1),'+
               ' CONSTRAINT PK_UCS_APP_INFO '+
               'PRIMARY KEY (APP_KEY))';

// Table: UCS_AUDIT
  auditSQL = 'CREATE TABLE UCS_AUDIT (APP_KEY VARCHAR(20) NOT NULL,'+
                'USER_ID FLOAT NOT NULL,'+
                'FORM_ID FLOAT NOT NULL,'+
                'COMP_ID FLOAT NOT NULL,'+
                'DATE_UTIL DOUBLE PRECISION NOT NULL,'+
                'COMPUTER_NAME VARCHAR(30),'+
                'ADDITIONAL_INFO1 VARCHAR(100),'+
//                'ADDITIONAL_INFO2 VARCHAR(100),'+
//                'ADDITIONAL_INFO2 BLOB,'+
//                'PRIMARY KEY (APP_KEY, USER_ID, FORM_ID, COMP_ID, DATE_UTIL))';
                'ADDITIONAL_INFO2 BLOB)';

// Table: UCS_HISTORY
  historySQL = 'CREATE TABLE UCS_HISTORY (USER_ID FLOAT NOT NULL,'+
               'USER_PWD VARCHAR(60) NOT NULL,'+
               'CHANGE_DATE FLOAT(8),'+
               ' CONSTRAINT PK_UCS_HISTORY '+
               'PRIMARY KEY (USER_ID, USER_PWD))';


// Table: UCS_PROFILES
  profilesSQL = 'CREATE TABLE UCS_PROFILES (PROF_DESCRIPTION VARCHAR(30) NOT NULL,'+
                'PROF_ID FLOAT,'+
                'INTERVAL_CHANGE_PWD FLOAT,'+
                'MUST_CHANGE_PWD VARCHAR(1),'+
                'AUDIT_MODE VARCHAR(1),'+
               ' CONSTRAINT PK_UCS_PROFILES '+
                'PRIMARY KEY (PROF_DESCRIPTION))';


// Table: UCS_FORMS
  formsSQL = 'CREATE TABLE UCS_FORMS (APP_KEY VARCHAR(20) NOT NULL ,'+
             'FORM_NAME VARCHAR(100) NOT NULL,'+
             'FORM_ID FLOAT,'+
             'FORM_CAPTION VARCHAR(100),'+
             ' CONSTRAINT PK_UCS_FORMS '+
             'PRIMARY KEY (APP_KEY, FORM_NAME))';

// Table: UCS_COMPS
  compsSQL = 'CREATE TABLE UCS_COMPS (APP_KEY VARCHAR(20) NOT NULL ,'+
             'FORM_ID FLOAT NOT NULL,'+
             'COMP_NAME VARCHAR(100) NOT NULL,'+
             'COMP_ID FLOAT,'+
             'COMP_CAPTION VARCHAR(100),'+
             'PARENT_ID FLOAT NOT NULL,'+
             ' CONSTRAINT PK_UCS_COMPS '+
             'PRIMARY KEY (APP_KEY, FORM_ID, COMP_NAME))';

// Table: UCS_USERS
  usersSQL = 'CREATE TABLE UCS_USERS (USERCS_NAME VARCHAR(30) NOT NULL ,'+
             'REAL_NAME VARCHAR(40),'+
             'USER_PWD VARCHAR(60) ,'+
             'USER_ID FLOAT,'+
             'LAST_PWD_CHANGE FLOAT,'+
             'PROFILE_ID FLOAT,'+
             'AUDIT_MODE VARCHAR(1),'+
             ' CONSTRAINT PK_UCS_USERS '+
             'PRIMARY KEY (USERCS_NAME))';

// Table: UCS_UACCESS
  uaccessSQL = 'CREATE TABLE UCS_UACCESS (APP_KEY VARCHAR(20) NOT NULL,'+
               'FORM_ID FLOAT NOT NULL,'+
               'COMP_ID FLOAT NOT NULL,'+
               'USER_ID FLOAT NOT NULL,'+
               'AUTHORIZED VARCHAR(1),'+
               ' CONSTRAINT PK_UCS_UACCESS '+
               'PRIMARY KEY(APP_KEY,FORM_ID,COMP_ID,USER_ID))';

// Table: UCS_PACCESS
  paccessSQL = 'CREATE TABLE UCS_PACCESS (APP_KEY VARCHAR(20) NOT NULL,'+
               'FORM_ID FLOAT NOT NULL,'+
               'COMP_ID FLOAT NOT NULL,'+
               'PROF_ID FLOAT NOT NULL,'+
               'AUTHORIZED VARCHAR(1),'+
               ' CONSTRAINT PK_UCS_PACCESS '+
               'PRIMARY KEY(APP_KEY,FORM_ID,COMP_ID,PROF_ID))';

// Table: UCS_USERINFO
  userinfoSQL ='CREATE TABLE UCS_USERINFO(APP_KEY VARCHAR(20) NOT NULL,'+
               'USER_ID FLOAT NOT NULL,'+
               'EXPIRATION_DATE FLOAT,'+
               'USER_EXPIRE VARCHAR(1),'+
               'USER_ACTIVE VARCHAR(1),'+
               'USER_IS_ADMIN VARCHAR(1),'+
               'ADDITIONAL_INFO VARCHAR(200),'+
               ' CONSTRAINT PK_UCS_USERINFO '+
               'PRIMARY KEY(APP_KEY, USER_ID))';

//  alterUserInfo = 'ALTER TABLE UCS_USERINFO ADD ADDITIONAL_INFO VARCHAR(200)';

// Table: UCS_LOGIN_TRACE
  logintraceSQL ='CREATE TABLE UCS_LOGIN_TRACE(APP_KEY VARCHAR(20) NOT NULL,'+
               'USER_ID FLOAT NOT NULL,'+
               'LOGIN_DATE_TIME DOUBLE PRECISION NOT NULL,'+
               'LOGOUT_DATE_TIME DOUBLE PRECISION,'+
               'COMPUTER_NAME VARCHAR(30),'+
               ' CONSTRAINT PK_UCS_LONGIN_TRACE '+
               'PRIMARY KEY (APP_KEY, USER_ID, LOGIN_DATE_TIME))';
var
//  qry : TIBQuery;
//  Tbl : TIBTable;
//  IBDataBase : TIBDataBase;
//  IBTransaction : TIBTransaction;
//  usersInsertMaster, pwd: String;
//  aDate: TDateTime;
//  DateStr: String;
//  lCriouTabela : boolean;
begin
  pwd := PChar('master');
  pwd := Encrypt(PChar(pwd));
  aDate:=Date;
  DateStr:=FloatToStr(aDate);
  usersInsertMaster := 'Insert into UCS_USERS values(''master'', ''master'','''+pwd+''',1,'+DateStr+',0,''1'')';

  result := true;
  IBDataBase := TIBDataBase.Create(nil);
  IBTransaction := TIBTransaction.Create(nil);
  IBTransaction.DefaultDatabase := IBDataBase;
  IBTransaction.Params.Add('read_committed');
  IBTransaction.Params.Add('rec_version');
  IBTransaction.Params.Add('nowait');
  IBDataBase.DefaultTransaction := IBTransaction;
  IBDataBase.AllowStreamedConnected := false;
  IBDataBase.Connected := false;
  IBDataBase.DatabaseName := sPath;
  IBDataBase.DefaultTransaction := IBTransaction;
  IBDataBase.LoginPrompt := false;
  IBDataBase.Params.Clear;
  IBDataBase.Params.Add( 'user_name=SYSDBA' );
  IBDataBase.Params.Add( 'password=masterkey' );
  IBDataBase.SQLDialect := 3;
  lCriouTabela := false;

  try
    try
      IBDataBase.Connected := true;
    except
      Result := false;
      Exit;
      {
      IBDataBase.Params.Clear;
      IBDataBase.Params.Add( 'USER "SYSDBA"' );
      IBDataBase.Params.Add( 'PASSWORD "masterkey"' );
      try
        IBDataBase.CreateDatabase;
        IBDataBase.Connected := true;
      except
        Result := false;
        Exit;
      end;
      }
    end;
    Tbl := TIBTable.Create(nil);
    Tbl.Database := IBDataBase;
    qry := TIBQuery.Create(nil);
    qry.Database := IBDataBase;

  // Cria tabelas para UsersIBX
    Tbl.TableName := 'UCS_APP_INFO';
    if not Tbl.Exists then begin
      qry.close;
      qry.SQL.clear;
      qry.SQL.Add( appInfoSQL );
      try
        qry.ExecSQL;
        qry.SQL.clear;
        lCriouTabela := true;
      except
        begin
          result := false;
        end;
      end;
    end;

    Tbl.TableName := 'UCS_AUDIT';
    if not Tbl.Exists then begin
      qry.close;
      qry.SQL.clear;
      qry.SQL.Add( AuditSQL );
      try
        qry.ExecSQL;
        qry.SQL.clear;
        lCriouTabela := true;
      except
        begin
          result := false;
        end;
      end;
    end;

    Tbl.TableName := 'UCS_HISTORY';
    if not Tbl.Exists then begin
      qry.close;
      qry.SQL.clear;
      qry.SQL.Add( HistorySQL );
      try
        qry.ExecSQL;
        qry.SQL.clear;
        lCriouTabela := true;
      except
        begin
          result := false;
        end;
      end;
    end;

    Tbl.TableName := 'UCS_PROFILES';
    if not Tbl.Exists then begin
      qry.close;
      qry.SQL.clear;
      qry.SQL.Add( ProfilesSQL );
      try
        qry.ExecSQL;
        qry.SQL.clear;
        lCriouTabela := true;
      except
        begin
          result := false;
        end;
      end;
    end;

    Tbl.TableName := 'UCS_FORMS';
    if not Tbl.Exists then begin
      qry.close;
      qry.SQL.clear;
      qry.SQL.Add( FormsSQL );
      try
        qry.ExecSQL;
        qry.SQL.clear;
        lCriouTabela := true;
      except
        begin
          result := false;
        end;
      end;
    end;

    Tbl.TableName := 'UCS_COMPS';
    if not Tbl.Exists then begin
      qry.close;
      qry.SQL.clear;
      qry.SQL.Add( CompsSQL );
      try
        qry.ExecSQL;
        qry.SQL.clear;
        lCriouTabela := true;
      except
        begin
          result := false;
        end;
      end;
    end;

    Tbl.TableName := 'UCS_USERS';
    if not Tbl.Exists then begin
      qry.close;
      qry.SQL.clear;
      qry.SQL.Add( UsersSQL );
      try
        qry.ExecSQL;
        qry.Close;
        qry.SQL.clear;
        lCriouTabela := true;
      except
        begin
          result := false;
        end;
      end;
    end;

    Tbl.TableName := 'UCS_UACCESS';
    if not Tbl.Exists then begin
      qry.close;
      qry.SQL.clear;
      qry.SQL.Add( UaccessSQL );
      try
        qry.ExecSQL;
        qry.SQL.clear;
        lCriouTabela := true;
      except
        begin
          result := false;
        end;
      end;
    end;

    Tbl.TableName := 'UCS_PACCESS';
    if not Tbl.Exists then begin
      qry.close;
      qry.SQL.clear;
      qry.SQL.Add( PaccessSQL );
      try
        qry.ExecSQL;
        qry.SQL.clear;
        lCriouTabela := true;
      except
        begin
          result := false;
        end;
      end;
    end;

    Tbl.TableName := 'UCS_USERINFO';
    if not Tbl.Exists then begin
      qry.close;
      qry.SQL.clear;
      qry.SQL.Add( UserInfoSQL );
      try
        qry.ExecSQL;
        qry.SQL.clear;
        lCriouTabela := true;
      except
        begin
          result := false;
        end;
      end;
    end;

    Tbl.TableName := 'UCS_LOGIN_TRACE';
    if not Tbl.Exists then begin
      qry.close;
      qry.SQL.clear;
      qry.SQL.Add( LoginTraceSQL );
      try
        qry.ExecSQL;
        qry.SQL.clear;
        lCriouTabela := true;
      except
        begin
          result := false;
        end;
      end;
    end;
  //Este Commit grava fisicamente as tabelas criadas.
    if lCriouTabela then begin
      IBTransaction.CommitRetaining;
    end;
    qry.Close;
    qry.SQL.Clear;
    qry.SQL.Add( 'SELECT * FROM UCS_USERS WHERE REAL_NAME = :pVar');
    qry.ParamByName( 'pVar' ).AsString := 'master';
    qry.Prepare;
    qry.Open;
    if qry.IsEmpty then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( usersInsertMaster );
      qry.ExecSQL;
      IBTransaction.CommitRetaining;
    end;
    qry.Close;
    qry.SQL.clear;

    //Coloca todos os usuários em modo de auditoria
    qry.SQL.Add( 'UPDATE UCS_PROFILES SET AUDIT_MODE = :pAuditMod WHERE AUDIT_MODE <> :pAuditMod');
    qry.ParamByName('pAuditMod').AsString := '1';
    qry.Prepare;
    qry.ExecSQL;

    //Coloca todos os perfis em modo de auditoria
    qry.SQL.Clear;
    qry.SQL.Add( 'UPDATE UCS_USERS SET AUDIT_MODE = :pAuditMod WHERE AUDIT_MODE <> :pAuditMod');
    qry.ParamByName('pAuditMod').AsString := '1';
    qry.Prepare;
    qry.ExecSQL;

    IBTransaction.CommitRetaining;

    Qry.Close;
    Qry.Free;
    Tbl.Close;
    Tbl.Free;
  finally
    IBDataBase.Connected := false;
    IBTransaction.Active := false;
    IBDataBase.Free;
    IBTransaction.Free;
  end;    }
end;

// Cria tabelas do MegaCadastro
function CriaTabCadastro(sPath:String): boolean;
var
  qry : TIBQuery;
  Tbl : TIBTable;
  IBDataBase : TIBDataBase;
  IBTransaction : TIBTransaction;
  lCriouTabela : boolean;
  MsgDlg1 : TEvMsgDlg;
begin
  result := true;
  IBDataBase := TIBDataBase.Create(nil);
  IBTransaction := TIBTransaction.Create(nil);
  IBTransaction.DefaultDatabase := IBDataBase;
  IBTransaction.Params.Add('read_committed');
  IBTransaction.Params.Add('rec_version');
  IBTransaction.Params.Add('nowait');
  IBDataBase.DefaultTransaction := IBTransaction;
  IBDataBase.AllowStreamedConnected := false;
  IBDataBase.Connected := false;
  IBDataBase.DatabaseName := sPath;
  IBDataBase.DefaultTransaction := IBTransaction;
  IBDataBase.LoginPrompt := false;
  IBDataBase.Params.Clear;
  IBDataBase.Params.Add( 'user_name=SYSDBA' );
  IBDataBase.Params.Add( 'password=masterkey' );
  IBDataBase.SQLDialect := 3;
  try
    try
      IBDataBase.Connected := true;
    except
      Result := false;
      Exit;
      {
      IBDataBase.Params.Clear;
      IBDataBase.Params.Add( 'USER "SYSDBA"' );
      IBDataBase.Params.Add( 'PASSWORD "masterkey"' );
      try
        IBDataBase.CreateDatabase;
        IBDataBase.Connected := true;
      except
        Result := false;
        Exit;
      end;
      }
    end;
    Tbl := TIBTable.Create(nil);
    Tbl.Database := IBDataBase;
    qry := TIBQuery.Create(nil);
    qry.Database := IBDataBase;

  // Cria tabela de cadastro das empresas
    Tbl.TableName := 'CADASTRO';
    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_CADASTRO PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD INSCMF VARCHAR(18), ADD NOME VARCHAR(50), ADD LOG VARCHAR(3)' );
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD ENDERECO VARCHAR(50), ADD NUMERO VARCHAR(6)' );
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD COMPL VARCHAR(100), ADD BAIRRO VARCHAR(30), ADD CIDADE VARCHAR(30), ADD ESTADO CHAR(2)' );
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD CEP CHAR(10), ADD TIPOINSCMF VARCHAR(4), ADD ORGAO_RC VARCHAR(30), ADD DTREGCOM TIMESTAMP' );
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD USA_END_COR CHAR(5), ADD LOG_COR VARCHAR(3)' );
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD ENDERECO_COR VARCHAR(50), ADD NUMERO_COR VARCHAR(6)' );
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD COMPL_COR VARCHAR(30), ADD BAIRRO_COR VARCHAR(30), ADD CIDADE_COR VARCHAR(30), ADD ESTADO_COR CHAR(2)' );
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD CEP_COR CHAR(10)' );
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD NUMREGCOM VARCHAR(20), ADD CODMUNICEST VARCHAR(5), ADD INSCEST VARCHAR(20), ADD TIPOINSCEST CHAR(2)' );
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD INDVESTUARIO CHAR(1), ADD CODATIVMUNIC VARCHAR(8), ADD INDUSTRIA CHAR(1)' );
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD COMERCIO CHAR(1), ADD TRANSPORTADORA CHAR(1), ADD SOCCIVIL CHAR(1), ADD CODINFAZ CHAR(4)' );
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD CODATIVEST CHAR(7), ADD REGIME_IR CHAR(2), ADD MATRIZ CHAR(1), ADD CNPJMATRIZ VARCHAR(18)' );
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD PROTEST VARCHAR(10), ADD DTPROTEST TIMESTAMP, ADD PROTPM VARCHAR(10), ADD DTPROTPM TIMESTAMP' );
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD PERCREDUCAO NUMERIC(6,2)' );
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD CODMUNICRAIS CHAR(8), ADD CODATIVRAIS CHAR(5), ADD NAT_JURIDICA CHAR(5), ADD DIASUTEIS NUMERIC, ADD VLTRANSP NUMERIC(18,2)' );
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD CODFPAS CHAR(3), ADD PERCFPAS NUMERIC(6,2), ADD CODSAT CHAR(8), ADD PERCSAT NUMERIC(6,2)' );
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD CODTERCEIROS CHAR(4), ADD PERCTERCEIROS NUMERIC(6,2), ADD PRIMDECLCAGED CHAR(1), ADD MUDOUEND CHAR(1)' );
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD ENCERROUATIV CHAR(1), ADD DTBASECATEG NUMERIC, ADD NUM_PROPRIET NUMERIC, ADD CONTADOR VARCHAR(45)' );
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD CPF_CONTADOR CHAR(14), ADD LOG_CONTADOR VARCHAR(3), ADD RUA_CONTADOR VARCHAR(50), ADD NUMERO_CONTADOR VARCHAR(6)' );
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD COMPL_CONTADOR VARCHAR(30), ADD BAIRRO_CONTADOR VARCHAR(30), ADD ESTADO_CONTADOR CHAR(2), ADD EST_CRC_CONTADOR CHAR(2)' );
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD FONE_CONTADOR CHAR(16), ADD CODMUNIC_CONTADOR CHAR(7), ADD CRC_CONTADOR VARCHAR(20), ADD PLANOGERAL CHAR(1)' );
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD CODREDUZ CHAR(1), ADD ESTRUTURA_PLANO VARCHAR(14), ADD NLIVRO_DIARIO NUMERIC, ADD NLIVRO_RAZAO NUMERIC' );
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD NLIVRO_CAIXA NUMERIC, ADD LIVRO_CAIXA CHAR(1), ADD CONTA_RESULTADO VARCHAR(14), ADD CONTA_LUCROS VARCHAR(14)' );
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD CONTA_CAPITAL VARCHAR(14), ADD CONTA_PREJUIZOS VARCHAR(14)' );
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD CONTA_GCAPITAL VARCHAR(14), ADD CONTA_INTEGRALIZAR VARCHAR(14), ADD CODREDUZAUTOM CHAR(1), ADD MES_BALANCO CHAR(2)' );
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD GRUPO_FORNECEDORES VARCHAR(9), ADD CONTABIL VARCHAR(5), ADD FISCAL VARCHAR(5), ADD PESSOAL VARCHAR(5), ADD FATURAMENTO VARCHAR(5)' );
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD CONTA_MERCTRANSITO VARCHAR(14), ADD CDHISTMERCTRANSITO INTEGER, ADD CAPITAL NUMERIC(18,2)');
          qry.ExecSQL;

          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD CONTA_RESULTADO_LEI11638 VARCHAR(14), ADD CONTA_LUCROS_LEI11638 VARCHAR(14)' );
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD CONTA_CAPITAL_LEI11638 VARCHAR(14), ADD CONTA_PREJUIZOS_LEI11638 VARCHAR(14)' );
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD CONTA_GCAPITAL_LEI11638 VARCHAR(14), ADD CONTA_INTEGRALIZAR_LEI11638 VARCHAR(14)' );
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD GRUPO_FORNECEDORES_LEI11638 VARCHAR(9)' );
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD CONTA_MERCTRANSITO_LEI11638 VARCHAR(14)');
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD BACK_CONTABIL CHAR(1), ADD BACK_PESSOAL CHAR(1), ADD BACK_FISCAL CHAR(1), ADD BACK_FATUR CHAR(1)');
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD INSCMUNIC VARCHAR(13), ADD OBS BLOB');
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD CODBCO CHAR(3), ADD CODAGE VARCHAR(6), ADD CONTA VARCHAR(15)' );
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD TPCOBRANCA CHAR(1), ADD PROTESTO CHAR(1)' );
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD COD_ATIV_MF CHAR(7), ADD CODMUNICMF CHAR(7), ADD DRE_ATUALIZADO CHAR(1)' );
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add('ALTER TABLE CADASTRO ADD NLIVRO_LALUR INTEGER, ADD E_MAIL VARCHAR(100), ADD GRUPO_CLIENTES VARCHAR(9)');
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add('ALTER TABLE CADASTRO ADD FORMACAO_CONTADOR VARCHAR(40)');
          qry.ExecSQL;
          qry.SQL.clear;
//          qry.SQL.Add('ALTER TABLE CADASTRO ADD LEI11638_2008 BOOLEAN, ADD GRUPO_FLUXO_CAIXA VARCHAR(7)');
          qry.SQL.Add('ALTER TABLE CADASTRO ADD LEI11638_2008 BOOLEAN');
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD GRUPO_CLIENTES_LEI11638 VARCHAR(9)');
          qry.ExecSQL;
          qry.SQL.clear;
//          qry.SQL.clear;
//          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD GRUPO_FLUXO_CAIXA_LEI11638 VARCHAR(7)');
//          qry.ExecSQL;
//          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE CADASTRO ADD CDHISTMERCTRANSITO_LEI11638 INTEGER');
          qry.ExecSQL;
          qry.SQL.clear;
          lCriouTabela := true;
        except
          begin
  //Todo -cPrioridade -oRoberto: Caso der erro no processo de criação verificar se a tabela foi criada e destruí-la
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end else begin //Ja existe a tabela CADASTRO
//      try    //Em 07.06.2009
//        qry.close;
//        qry.SQL.clear;
//        qry.SQL.Add('ALTER TABLE CADASTRO ADD GRUPO_FLUXO_CAIXA VARCHAR(7)');
//        qry.ExecSQL;
//        qry.SQL.clear;
//        lCriouTabela := true;
//      except
//      end;

      try //Em 08.09.2009
        qry.SQL.clear;
        qry.SQL.Add( 'ALTER TABLE CADASTRO ADD CONTA_RESULTADO_LEI11638 VARCHAR(14), ADD CONTA_LUCROS_LEI11638 VARCHAR(14)' );
        qry.ExecSQL;
        qry.SQL.clear;
        qry.SQL.Add( 'ALTER TABLE CADASTRO ADD CONTA_CAPITAL_LEI11638 VARCHAR(14), ADD CONTA_PREJUIZOS_LEI11638 VARCHAR(14)' );
        qry.ExecSQL;
        qry.SQL.clear;
        qry.SQL.Add( 'ALTER TABLE CADASTRO ADD CONTA_GCAPITAL_LEI11638 VARCHAR(14), ADD CONTA_INTEGRALIZAR_LEI11638 VARCHAR(14)' );
        qry.ExecSQL;
        qry.SQL.clear;
        qry.SQL.Add( 'ALTER TABLE CADASTRO ADD GRUPO_FORNECEDORES_LEI11638 VARCHAR(9)' );
        qry.ExecSQL;
        qry.SQL.clear;
        qry.SQL.Add( 'ALTER TABLE CADASTRO ADD CONTA_MERCTRANSITO_LEI11638 VARCHAR(14)');
        qry.ExecSQL;
        qry.SQL.clear;
      except
      end;

      try //Em 10.09.2009
        qry.SQL.clear;
        qry.SQL.Add( 'ALTER TABLE CADASTRO ADD GRUPO_CLIENTES_LEI11638 VARCHAR(9)');
        qry.ExecSQL;
        qry.SQL.clear;
      except
      end;
//      try //Em 10.09.2009
//        qry.SQL.clear;
//        qry.SQL.Add( 'ALTER TABLE CADASTRO ADD GRUPO_FLUXO_CAIXA_LEI11638 VARCHAR(7)');
//        qry.ExecSQL;
//        qry.SQL.clear;
//      except
//      end;
      try //Em 10.09.2009
        qry.SQL.clear;
        qry.SQL.Add( 'ALTER TABLE CADASTRO ADD CDHISTMERCTRANSITO_LEI11638 INTEGER');
        qry.ExecSQL;
        qry.SQL.clear;
      except
      end;

    end;

  // Cria arquivo de Sócios
    Tbl.TableName := 'CSOCIOS';
    if Tbl.Exists then begin
  //  Depois tirar isto (colocado na versão 1.0.0.21-MegaCadastro)
      qry.close;
      qry.SQL.clear;
      qry.SQL.Add('SELECT * FROM '+Tbl.TableName);
      qry.Open;
      if qry.FieldDefs.IndexOf('FONE') >= 0 then begin
        if Qry.FieldByName('FONE').DisplayWidth < 16 then begin
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add('DROP TABLE '+Tbl.TableName);
          qry.ExecSQL;
          IBTransaction.CommitRetaining;
        end;
      end;
    end;

    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_CSOCIOS PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD EMPRESA INTEGER NOT NULL, ADD INSCMF VARCHAR(18) NOT NULL');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD NOME VARCHAR(60), ADD FONE CHAR(16), ADD EMAIL VARCHAR(40), ADD CARGO VARCHAR(50)');
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD GERENTE VARCHAR(5), ADD RESPMF VARCHAR(5), ADD TIPO VARCHAR(8), ADD PERCPARTCAPITAL NUMERIC(18,2)' );
          qry.ExecSQL;
          qry.SQL.clear;
          lCriouTabela := true;
        except
          begin
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end;

  // Cria tabela de Bancos
    Tbl.TableName := 'BANCOS';
    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_BANCOS PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD CODBCO CHAR(3) NOT NULL');
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD BANCO VARCHAR(50)' );
          qry.ExecSQL;
          qry.SQL.clear;
          lCriouTabela := true;
        except
          begin
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end;

  // Cria tabela de Agencias Bancárias
    Tbl.TableName := 'AGENCIAS';
    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_AGENCIAS PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.SQL.Add('ALTER TABLE ' + Tbl.TableName + ' ADD CODBCO CHAR(3) NOT NULL, ADD CODAGE VARCHAR(6) NOT NULL');
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add('ALTER TABLE ' + Tbl.TableName + ' ADD DGVER VARCHAR(2), ADD AGENCIA VARCHAR(50)');
          qry.ExecSQL;
          qry.SQL.clear;
          lCriouTabela := true;
        except
          begin
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end;

  // Cria arquivo de Feriados
    Tbl.TableName := 'FERIADOS';
    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID_FERIADOS ID NOT NULL, CONSTRAINT PK_FERIADOS PRIMARY KEY(ID_FERIADOS))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.SQL.Add( 'ALTER TABLE FERIADOS ADD DATA DATE NOT NULL');
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE FERIADOS ADD DESCRICAO VARCHAR(50)' );
          qry.ExecSQL;
          qry.SQL.clear;
          lCriouTabela := true;
        except
          begin
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end;

  // Cria arquivo Moedas/Índices
    Tbl.TableName := 'MOEDAS';
    if not Tbl.Exists then begin
      qry.close;
      qry.SQL.clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_MOEDAS PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.SQL.Add( 'ALTER TABLE MOEDAS ADD CODIGO INTEGER NOT NULL');
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE MOEDAS ADD DESCRICAO VARCHAR(50)' );
          qry.ExecSQL;
          qry.SQL.clear;
          lCriouTabela := true;
        except
          begin
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end;

  // Cria arquivo Valores Moedas/Índices
    Tbl.TableName := 'VLMOEDAS';
    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_VLMOEDAS PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.SQL.Add( 'ALTER TABLE VLMOEDAS ADD CODIGO INTEGER NOT NULL, ADD DATA TIMESTAMP NOT NULL');
          qry.ExecSQL;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE VLMOEDAS ADD VALOR NUMERIC(18,6) NOT NULL' );
          qry.ExecSQL;
          qry.SQL.clear;
          lCriouTabela := true;
        except
          begin
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end;

  // Cria tabela de Tipos Gerais
    Tbl.TableName := 'GTIPOS';
    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID_GTIPOS ID NOT NULL, CONSTRAINT PK_GTIPOS PRIMARY KEY(ID_GTIPOS))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD TIPO INTEGER NOT NULL, ADD CODIGO VARCHAR(10) NOT NULL, ADD DESCRICAO VARCHAR(40) NOT NULL');
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        lCriouTabela := true;
      except
        begin
          result := false;
        end;
      end;
    end;

  //Este Commit grava fisicamente as tabelas criadas.
    if lCriouTabela then begin
      IBTransaction.CommitRetaining;
    end;

    Try
      //GTIPOS
//      Qry.Close;
//      Qry.SQL.Clear;
//      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_GTIPOS' );
//      Qry.ExecSQL;
//      Qry.Close;
//      Qry.SQL.Clear;
//      Qry.SQL.Add( 'SET GENERATOR GEN_ID_GTIPOS TO 0' );
//      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      //MOEDAS
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_MOEDAS' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_MOEDAS TO 0' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      //VLMOEDAS
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_VLMOEDAS' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_VLMOEDAS TO 0' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
//      //GEN CADASTRO
//      Qry.Close;
//      Qry.SQL.Clear;
//      Qry.SQL.Add( 'CREATE GENERATOR GEN_CADASTRO' );
//      Qry.ExecSQL;
//      Qry.Close;
//      Qry.SQL.Clear;
//      Qry.SQL.Add( 'SET GENERATOR GEN_CADASTRO TO 0' );
//      Qry.ExecSQL;
//      Qry.Close;
      //GEN ID CADASTRO
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_CADASTRO' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_CADASTRO TO 0' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      //AGENCIAS
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_AGENCIAS' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_AGENCIAS TO 0' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      //BANCOS
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_BANCOS' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_BANCOS TO 0' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      //FERIADOS
//      Qry.Close;
//      Qry.SQL.Clear;
//      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_FERIADOS' );
//      Qry.ExecSQL;
//      Qry.Close;
//      Qry.SQL.Clear;
//      Qry.SQL.Add( 'SET GENERATOR GEN_ID_FERIADOS TO 0' );
//      Qry.ExecSQL;
//      Qry.Close;
//      Qry.SQL.Clear;
      //SOCIOS
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_SOCIOS' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_SOCIOS TO 0' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      IBTransaction.CommitRetaining;
    except
      Qry.Close;
  //  Não faz nada
    end;

    Qry.Close;
    Qry.Free;
    Tbl.Close;
    Tbl.Free;
  finally
    IBDataBase.Connected := false;
    IBTransaction.Active := false;
    IBDataBase.Free;
    IBTransaction.Free;
  end;
end;

// Cria tabelas do MegaContabil
function CriaTabContabil(sPath:string): Boolean;
var
  qry : TIBQuery;
  Tbl : TIBTable;
  IBDataBase : TIBDataBase;
  IBTransaction : TIBTransaction;
  lCriouTabela : boolean;
  IBScript : TIBScript;
  sPathExe : String;
begin
  sPathExe := ExtractFilePath(ParamStr(0));
  result := true;
  lCriouTabela := false;
  IBDataBase := TIBDataBase.Create(nil);
  IBTransaction := TIBTransaction.Create(nil);
  IBTransaction.DefaultDatabase := IBDataBase;
  IBTransaction.Params.Add('read_committed');
  IBTransaction.Params.Add('rec_version');
  IBTransaction.Params.Add('nowait');
  IBDataBase.DefaultTransaction := IBTransaction;
  IBDataBase.AllowStreamedConnected := false;
  IBDataBase.Connected := false;
  IBDataBase.DatabaseName := sPath;
  IBDataBase.DefaultTransaction := IBTransaction;
  IBDataBase.LoginPrompt := false;
  IBDataBase.Params.Clear;
  IBDataBase.Params.Add( 'user_name=SYSDBA' );
  IBDataBase.Params.Add( 'password=masterkey' );
  IBDataBase.SQLDialect := 3;
  try
    try
      IBDataBase.Connected := true;
    except
      Result := false;
      Exit;
      {
      IBDataBase.Params.Clear;
      IBDataBase.Params.Add( 'USER "SYSDBA"' );
      IBDataBase.Params.Add( 'PASSWORD "masterkey"' );
      try
        IBDataBase.CreateDatabase;
        IBDataBase.Connected := true;
      except
        Result := false;
        Exit;
      end;
      }
    end;
    Tbl := TIBTable.Create(nil);
    Tbl.Database := IBDataBase;
    qry := TIBQuery.Create(nil);
    qry.Database := IBDataBase;
    Tbl.TableName := 'CEVENTOS_SINCO';
    if not Tbl.Exists then begin
      IBScript := TIBScript.Create(nil);
      IBScript.Database := IBDataBase;
      IBScript.Transaction := IBTransaction;

      IBScript.Script.Clear;
      IBScript.Script.LoadFromFile(sPathExe+'\SQLScripts\CEVENTOS_SINCO.sql');
      IBScript.ExecuteScript;
      IBScript.Free;
    end;

    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_CPARAMETROS PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD ESTRUTURA_PLANO_GERAL VARCHAR(14) NOT NULL, ADD INSCMF VARCHAR(18), ADD NOME_RESPONSAVEL VARCHAR(50), ADD E_MAIL VARCHAR(50)');
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD TAMANHO_PAGINA_REL SMALLINT, ADD COLUNA_REL SMALLINT' );
        qry.ExecSQL;
        qry.SQL.clear;
        lCriouTabela := true;
      except
        begin
          result := false;
        end;
      end;
    end;


  // Cria tabela de Parametros gerais
    Tbl.TableName := 'CPARAMETROS';
    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_CPARAMETROS PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD ESTRUTURA_PLANO_GERAL VARCHAR(14) NOT NULL, ADD INSCMF VARCHAR(18), ADD NOME_RESPONSAVEL VARCHAR(50), ADD E_MAIL VARCHAR(50)');
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD TAMANHO_PAGINA_REL SMALLINT, ADD COLUNA_REL SMALLINT' );
        qry.ExecSQL;
        qry.SQL.clear;
        lCriouTabela := true;
      except
        begin
          result := false;
        end;
      end;
    end;

  // Cria arquivo de Controle de Backup
    Tbl.TableName := 'CBACKUP';
    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_CBACKUP PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD ANO CHAR(4) NOT NULL, ADD EMPRESA INTEGER NOT NULL');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD NOME VARCHAR(50), ADD DATA TIMESTAMP, ADD USUARIO VARCHAR(50), ADD ATUALIZADO CHAR(1)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          lCriouTabela := true;
        except
          begin
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end;

  // Cria arquivo de Controle de Contas Negativas
    Tbl.TableName := 'CCTNEG';
    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_CCTNEG PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD ANO CHAR(4) NOT NULL, ADD EMPRESA INTEGER NOT NULL');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD NOME VARCHAR(50), ADD DATA TIMESTAMP, ADD USUARIO VARCHAR(50), ADD CTNEG CHAR(1)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          lCriouTabela := true;
        except
          begin
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end;

  // Cria arquivo de Plano de Contas Geral
    Tbl.TableName := 'CPLANOGERAL';
    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_CPLANOGERAL PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD ID_CPLANOGERAL ID');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD CONTA VARCHAR(14) NOT NULL');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD DGVER CHAR(1) NOT NULL, ADD CODREDUZ NUMERIC NOT NULL, ADD DGREDUZ CHAR(1) NOT NULL' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD INSCMF VARCHAR(18), ADD NMCONTA VARCHAR(50) NOT NULL, ADD TIPO CHAR(1) NOT NULL, ADD GRAU CHAR(1) NOT NULL' );
          qry.ExecSQL;

          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD ORDEM_DIPJ INTEGER' );
          qry.ExecSQL;
          qry.close;

          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD CONTA_REFERENCIAL VARCHAR(20)' );
          qry.ExecSQL;
          qry.close;

          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD LEI11638 BOOLEAN, ADD NATUREZA SMALLINT, ADD CAIXA BOOLEAN DEFAULT 0' );
          qry.ExecSQL;
          qry.SQL.clear;

          Qry.Close;
          Qry.SQL.Clear;
          Qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD constraint CHK_CPLANOGERAL_NATUREZA CHECK (NATUREZA BETWEEN 0 AND 5)' );
          Qry.ExecSQL;

          lCriouTabela := true;
        except
          begin
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end else begin
      try //Início 19.06.2009
        Qry.Close;
        Qry.SQL.Clear;
        Qry.SQL.Add('ALTER TABLE '+Tbl.TableName+' ADD CAIXA BOOLEAN DEFAULT 0');
        Qry.ExecSQL;
        lCriouTabela := true;
      except
      end;
    end;

  // Cria arquivo de Plano de Contas Empresa
    Tbl.TableName := 'CPLANOEMPRESA';
    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
//      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_CPLANOEMPRESA PRIMARY KEY(ID))');
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID_CPLANOEMPRESA ID, CONSTRAINT PK_CPLANOEMPRESA PRIMARY KEY(ID_CPLANOEMPRESA))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD EMPRESA INTEGER NOT NULL, ADD CONTA VARCHAR(14) NOT NULL');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
//          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD DGVER CHAR(1) NOT NULL, ADD CODREDUZ SMALLINT NOT NULL, ADD DGREDUZ CHAR(1) NOT NULL' );
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD DGVER CHAR(1), ADD CODREDUZ SMALLINT NOT NULL, ADD DGREDUZ CHAR(1)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD INSCMF CHAR(18), ADD NMCONTA VARCHAR(50) NOT NULL, ADD TIPO CHAR(1) NOT NULL, ADD GRAU SMALLINT NOT NULL' );
//          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD INSCMF CHAR(18), ADD TIPO CHAR(1) NOT NULL, ADD GRAU SMALLINT NOT NULL' );
          qry.ExecSQL;
          qry.close;

          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD ORDEM_DIPJ INTEGER, ADD SALDO_DRE NUMERIC(18,2), ADD SDEXEANT NUMERIC(18,2)' );
          qry.ExecSQL;
          qry.close;

          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD LEI11638 BOOLEAN, ADD RELACIONAMENTO SMALLINT DEFAULT 0, ADD NATUREZA SMALLINT' );
          qry.ExecSQL;
          qry.close;

          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD CAIXA BOOLEAN DEFAULT 0' );
          qry.ExecSQL;
          qry.close;

          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD CONTA_REFERENCIAL VARCHAR(20)' );
          qry.ExecSQL;
          qry.close;

          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD constraint CHK_CPLANOEMPRESA_RELACIONAMENT CHECK (RELACIONAMENTO < 12)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;

          Qry.Close;
          Qry.SQL.Clear;
          Qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD constraint CHK_CPLANOEMPRESA_NATUREZA CHECK (NATUREZA BETWEEN 0 AND 5)' );
          Qry.ExecSQL;

          lCriouTabela := true;
        except
          begin
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end else begin
      try  //Início 19.06.2009
        Qry.Close;
        Qry.SQL.Clear;
        Qry.SQL.Add('ALTER TABLE '+Tbl.TableName+' ADD CAIXA BOOLEAN DEFAULT 0');
        Qry.ExecSQL;
        lCriouTabela := true;
      except
      end;
    end;
  // Cria arquivo de Saldo das Contas
    Tbl.TableName := 'CSALDO_CONTAS';
    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_CSALDO_CONTAS PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD EMPRESA INTEGER NOT NULL, ADD CONTA VARCHAR(14) NOT NULL, ADD FILIAL INTEGER NOT NULL, ADD CCUSTO INTEGER NOT NULL');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD DATA TIMESTAMP NOT NULL, ADD VL_DEBITO NUMERIC(18,2) NOT NULL, ADD VL_CREDITO NUMERIC(18,2) NOT NULL, ADD HIST62 SMALLINT' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          lCriouTabela := true;
        except
          begin
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end;

  // Cria arquivo de Plano de Historicos
    Tbl.TableName := 'CPLANOHISTORICO';
    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID_CPLANOHISTORICO ID, CONSTRAINT PK_CPLANOHISTORICO PRIMARY KEY(ID_CPLANOHISTORICO))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD CDHIST INTEGER NOT NULL');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD HISTORICO VARCHAR(50) NOT NULL, ADD TIPO_FLUXO_CAIXA SMALLINT DEFAULT 0 NOT NULL' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;

          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD DESCRICAO_FLUXO_CAIXA VARCHAR(50)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;

          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD CONSTRAINT CHK_CPLANOHISTORICO_TP_FLUXO_CX check (TIPO_FLUXO_CAIXA BETWEEN 0 AND 3)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;

          lCriouTabela := true;
        except
          begin
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end else begin
      try  //Em 08.09.2009
        qry.close;
        qry.SQL.clear;
        qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD DESCRICAO_FLUXO_CAIXA VARCHAR(50)' );
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
      except
      end;
    end;
  // Cria arquivo de Grupos do Permanente
    Tbl.TableName := 'CGRUPOS_PERMANENTE';
    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_CGRUPOS_PERMANENTE PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD EMPRESA INTEGER NOT NULL, ADD GRUPO INTEGER NOT NULL');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD DESCRICAO VARCHAR(50) NOT NULL' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          lCriouTabela := true;
        except
          begin
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end;

  // Cria CFLUXO_CAIXA
    Tbl.TableName := 'CFLUXO_CAIXA';
    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID_CFLUXO_CAIXA ID NOT NULL, CONSTRAINT PK_CFLUXO_CAIXA PRIMARY KEY(ID_CFLUXO_CAIXA))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD TIPO SMALLINT NOT NULL, ADD DESCRICAO VARCHAR(100) NOT NULL');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
//          qry.SQL.Add( 'DESCRIBE FIELD TIPO TABLE ' + Tbl.TableName + quotedStr('0 = FLUXO DE CAIXA DAS ATIVIDADES OPERACIONAIS 1 = FLUXO DE CAIXA DAS ATIVIDADES DE INVESTIMENTO 2 = FLUXO DE CAIXA DAS ATIVIDADES DE FINANCIAMENTO'));
//          qry.ExecSQL;
//          qry.close;
//          qry.SQL.clear;
        except
          begin
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end;

    try
      qry.close;
      qry.SQL.clear;
      qry.SQL.Add( 'ALTER TABLE CFLUXO_CAIXA ADD CONSTRAINT cfluxo_caixa_tipo CHECK (TIPO >= 0 AND TIPO <= 2)');
      qry.ExecSQL;
      qry.close;
      qry.SQL.clear;
    except
    end;

  // Cria arquivo de Lancamentos
    Tbl.TableName := 'CLANCAMENTOS';
    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_CLANCAMENTOS PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD EMPRESA INTEGER NOT NULL, ADD ANO CHAR(4) NOT NULL, ADD LOTE INTEGER NOT NULL, ADD LINHA INTEGER NOT NULL');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD CCUSTO INTEGER, ADD FILIAL INTEGER, ADD DTLANC TIMESTAMP' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD DATA TIMESTAMP NOT NULL, ADD TIPO CHAR(1) NOT NULL, ADD CONTA_DEB VARCHAR(14)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD DGDEB CHAR(1), ADD CONTA_CRE VARCHAR(14), ADD DGCRE CHAR(1)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD CDREDUZDEB INTEGER, ADD DGREDUZDEB CHAR(1), ADD CDREDUZCRE INTEGER' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD DGREDUZCRE CHAR(1), ADD CDHIST INTEGER NOT NULL, ADD HISTORICO VARCHAR(50)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD COMPL VARCHAR(500), ADD VALOR NUMERIC(18,2) NOT NULL, ADD LALUR SMALLINT' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD GRUPOIMOB INTEGER, ADD CODIMOB INTEGER, ADD EXEC_TRIGGER CHAR(1)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD FK_CFLUXO_CAIXA  ID' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD SPED_FCONT BOOLEAN DEFAULT 0' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          lCriouTabela := true;
        except
          begin
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end else begin
      try
        qry.close;  //Em 07.06.2009
        qry.SQL.clear;
        qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD FK_CFLUXO_CAIXA  ID' );
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        lCriouTabela := true;
      except
      end;  
    end;

    try
      qry.close;
      qry.SQL.clear;
      qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD CONSTRAINT FK_CLANCAMENTOS_CFLUXO_CAIXA FOREIGN KEY (FK_CFLUXO_CAIXA) REFERENCES CFLUXO_CAIXA (ID_CFLUXO_CAIXA)' );
      qry.ExecSQL;
      qry.close;
      qry.SQL.clear;
    except
    end;

  // Cria arquivo de Saldo Caixa
    Tbl.TableName := 'CSDOCAIXA';
    if Tbl.Exists then begin
  //  Depois tirar isto (colocado na versão 1.0.0.57-MegaContabil)
      qry.close;
      qry.SQL.clear;
      qry.SQL.Add( 'SELECT * FROM '+Tbl.TableName);
      qry.Open;
      if qry.FieldDefs.IndexOf('ANO') >= 0 then begin
        qry.close;
        qry.SQL.clear;
        qry.SQL.Add( 'DROP TABLE '+Tbl.TableName);
        qry.ExecSQL;
        IBTransaction.CommitRetaining;
      end;
    end;

    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_CSDOCAIXA PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD EMPRESA INTEGER NOT NULL');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD SALDO NUMERIC(18,2)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          lCriouTabela := true;
        except
          begin
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end;

  // Cria arquivo de Lancamentos do livro caixa
    Tbl.TableName := 'CLANCCAIXA';
    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_CLANCCAIXA PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
  //        qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD LINHA INTEGER NOT NULL');
  //        qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD EMPRESA INTEGER, ADD ANO CHAR(4), ADD DTLANC TIMESTAMP' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD DATA TIMESTAMP NOT NULL, ADD TIPO CHAR(1) NOT NULL' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD CDHIST INTEGER NOT NULL, ADD HISTORICO VARCHAR(50)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD COMPL VARCHAR(500), ADD VALOR NUMERIC(18,2) NOT NULL' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD REC_DESP SMALLINT' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;

          lCriouTabela := true;
        except
          begin
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end;

  // Cria arquivo de Integração
    Tbl.TableName := 'CINTEGRA';
    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_CINTEGRA PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD EMPRESA INTEGER NOT NULL, ADD ANO CHAR(4) NOT NULL, ADD LOTE INTEGER NOT NULL, ADD LINHA INTEGER NOT NULL');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD DTLANC TIMESTAMP' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD DATA TIMESTAMP NOT NULL, ADD CTDEST VARCHAR(14), ADD DGCTDEST CHAR(1)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD CTPART VARCHAR(14), ADD DGCTPART CHAR(1)');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD CDHIST INTEGER NOT NULL, ADD HISTORICO VARCHAR(50)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD COMPL VARCHAR(500), ADD VALOR NUMERIC(18,2) NOT NULL' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD OUT_ENT NUMERIC(18,2), ADD OUT_SAI NUMERIC(18,2), ADD CODFISC CHAR(5)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD CGC VARCHAR(18), ADD TIPO VARCHAR(10), ADD TIPOLANC CHAR(1), ADD VALIDO VARCHAR(5) NOT NULL');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD ORIGEM VARCHAR(8) NOT NULL, ADD PROGRAMA SMALLINT');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          lCriouTabela := true;
        except
          begin
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end;

  // Cria arquivo de Lancamentos da CM / Depreciação antes da transferência para Contabilidade.
    Tbl.TableName := 'CLANCAM_IMOB';
    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_CLANCAM_IMOB PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD EMPRESA INTEGER NOT NULL, ADD ANO CHAR(4) NOT NULL, ADD DATA TIMESTAMP NOT NULL, ADD GRUPO INTEGER NOT NULL, ADD CODIGO INTEGER NOT NULL, ADD TIPO CHAR(1) NOT NULL');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD CCUSTO INTEGER, ADD FILIAL INTEGER' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD CONTA_DEB VARCHAR(14)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD CONTA_CRE VARCHAR(14), ADD CDHIST INTEGER, ADD HISTORICO VARCHAR(50)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD TXDEP NUMERIC(18,2), ADD VALOR_BEM NUMERIC(18,2), ADD VALOR NUMERIC(18,2)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          lCriouTabela := true;
        except
          begin
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end;

//    if GetEnvironmentVariable('MEGASOFT') = 'MEGASOFT' then begin
      // Cria arquivo da Parte B do Lalur
      Tbl.TableName := 'CLALUR_PARTE_B';
      if not Tbl.Exists then begin
        qry.Close;
        qry.SQL.Clear;
        qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_CLALUR_PARTE_B PRIMARY KEY(ID))');
        try
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          try
            qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD EMPRESA INTEGER NOT NULL, ADD CONTA INTEGER NOT NULL');
            qry.ExecSQL;
            qry.close;
            qry.SQL.clear;
            qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD VALOR NUMERIC(18,2) NOT NULL, ADD TIPO SMALLINT NOT NULL, ADD DATA TIMESTAMP NOT NULL, ADD HISTORICO VARCHAR(500) NOT NULL');
            qry.ExecSQL;
            qry.close;
            qry.SQL.clear;
            lCriouTabela := true;
          except
            begin
              result := false;
            end;
          end;
        except
          begin
            result := false;
          end;
        end;
      end;

      // Cria arquivo de Cadastro de Contas do Lalur Parte B
      Tbl.TableName := 'CCONTAS_LALUR_PARTE_B';
      if not Tbl.Exists then begin
        qry.Close;
        qry.SQL.Clear;
        qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_CCONTAS_LALUR_PARTE_B PRIMARY KEY(ID))');
        try
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          try
            qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD EMPRESA INTEGER NOT NULL');
            qry.ExecSQL;
            qry.close;
            qry.SQL.clear;
            qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD CONTA INTEGER NOT NULL, ADD DESCRICAO VARCHAR(50) NOT NULL');
            qry.ExecSQL;
            qry.close;
            qry.SQL.clear;
            lCriouTabela := true;
          except
            begin
              result := false;
            end;
          end;
        except
          begin
            result := false;
          end;
        end;
      end;
//    end;

  // Cria arquivo de Lotes
    Tbl.TableName := 'CLOTES';
    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_CLOTES PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD EMPRESA INTEGER NOT NULL, ADD ANO CHAR(4) NOT NULL, ADD LOTE INTEGER NOT NULL');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD TOTAL NUMERIC(18,2), ADD DEBITO NUMERIC(18,2), ADD CREDITO NUMERIC(18,2), ADD USUARIO VARCHAR(50), ADD ESTACAO VARCHAR(50)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD IDENTIFICACAO VARCHAR(50), ADD EXEC_TRIGGER CHAR(1)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          lCriouTabela := true;
        except
          begin
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end;

  // Cria arquivo de Diferencas de lotes
    Tbl.TableName := 'CLOTES_ERROR';
    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_CLOTES_ERROR PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD EMPRESA INTEGER NOT NULL, ADD ANO CHAR(4) NOT NULL, ADD LOTE INTEGER NOT NULL');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD TOTAL NUMERIC(18,2), ADD DEBITO NUMERIC(18,2), ADD CREDITO NUMERIC(18,2)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD DIFERENCA NUMERIC(18,2)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          lCriouTabela := true;
        except
          begin
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end;

  // Cria arquivo de Diferencas em datas
    Tbl.TableName := 'CDATAS_ERROR';
    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_CDATAS_ERROR PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD EMPRESA INTEGER NOT NULL, ADD ANO CHAR(4) NOT NULL, ADD DATA TIMESTAMP NOT NULL');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD TOTAL NUMERIC(18,2), ADD DEBITO NUMERIC(18,2), ADD CREDITO NUMERIC(18,2)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD DIFERENCA NUMERIC(18,2)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          lCriouTabela := true;
        except
          begin
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end;

  // Cria arquivo de Centro de Custos
    Tbl.TableName := 'CCUSTOS';
    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_CCUSTOS PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD EMPRESA INTEGER NOT NULL, ADD CODIGO INTEGER NOT NULL');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD DESCRICAO VARCHAR(50)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          lCriouTabela := true;
        except
          begin
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end;

  // Cria arquivo de Filiais
    Tbl.TableName := 'CFILIAIS';
    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_CFILIAIS PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD EMPRESA INTEGER NOT NULL, ADD CODIGO INTEGER NOT NULL');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD DESCRICAO VARCHAR(50)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          lCriouTabela := true;
        except
          begin
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end;

  // Cria arquivo de Bens Permanente
    Tbl.TableName := 'CBENS_PERMANENTE';
    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_CBENS_PERMANENTE PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD EMPRESA INTEGER NOT NULL, ADD GRUPO INTEGER NOT NULL, ADD CODIGO INTEGER NOT NULL');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD DESCRICAO VARCHAR(50), ADD DATAAQ TIMESTAMP NOT NULL, ADD VALORAQ NUMERIC(18,2) NOT NULL, ADD TXDEP NUMERIC(6,2)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD CTDESTCM VARCHAR(14), ADD CTDESTDP VARCHAR(14), ADD CTPARTCM VARCHAR(14), ADD CTPARTDP VARCHAR(14)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD INDICE INTEGER, ADD QTINDICE NUMERIC(18,4), ADD VLCMAC NUMERIC(18,4), ADD TXDEPAC NUMERIC(9,4), ADD TIPO VARCHAR(11)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD CCUSTO INTEGER, ADD FILIAL INTEGER' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE '+ Tbl.TableName + ' ADD CTDESTDP_LEI11638 VARCHAR(14), ADD CTPARTDP_LEI11638 VARCHAR(14)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE '+ Tbl.TableName + ' ADD CTDESTCM_LEI11638 VARCHAR(14), ADD CTPARTCM_LEI11638 VARCHAR(14)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          lCriouTabela := true;
        except
          begin
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end else begin
      try  //Inlcuido em 05/2009
        qry.SQL.clear;
        qry.SQL.Add( 'ALTER TABLE '+ Tbl.TableName + ' ADD CTDESTCM_LEI11638 VARCHAR(14), ADD CTPARTCM_LEI11638 VARCHAR(14)' );
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        lCriouTabela := true;
      except
        result := false;
      end;
    end;

  // Cria arquivo de Baixa de Bens Permanente
    Tbl.TableName := 'CBAIXA_PERMANENTE';
    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_CBAIXA_PERMANENTE PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD EMPRESA INTEGER NOT NULL, ADD ANO CHAR(4) NOT NULL, ADD GRUPO INTEGER NOT NULL, ADD CODIGO INTEGER NOT NULL, ADD DATA TIMESTAMP NOT NULL');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD QTINDICE NUMERIC(18,4), ADD PERC_BAIXADO NUMERIC(9,4), ADD VL_BX_BEM NUMERIC(18,2), ADD VL_BX_DEP NUMERIC(18,2)');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          lCriouTabela := true;
        except
          begin
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end;

  // Cria arquivo de valores de Correção / Depreciação do Permanente
    Tbl.TableName := 'CCM_DP_PERMANENTE';
    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_CCM_DP_PERMANENTE PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD EMPRESA INTEGER NOT NULL, ADD ANO CHAR(4) NOT NULL, ADD GRUPO INTEGER NOT NULL, ADD CODIGO INTEGER NOT NULL, ADD TIPO VARCHAR(20) NOT NULL, ADD DATA TIMESTAMP NOT NULL');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD PERCENTUAL NUMERIC(18,6), ADD VALOR NUMERIC(18,2)');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          lCriouTabela := true;
        except
          begin
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end;

  // Cria arquivo de Contas Correntes e Contas do Pat. Líquido sujeitas a Correção Monetária
    Tbl.TableName := 'CM_CC_PL';
    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_CM_CC_PL PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD EMPRESA INTEGER NOT NULL, ADD CONTA VARCHAR(14) NOT NULL');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD TIPO VARCHAR(20), ADD CTDESTCM VARCHAR(14), ADD CTPARTCM VARCHAR(14)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          lCriouTabela := true;
        except
          begin
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end;

  // Cria arquivo de Fichas do Imposto de Renda
    Tbl.TableName := 'CFICHAS_IR';
    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_CFICHAS_IR PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD BALANCO_DRE CHAR(1), ADD ORDEM_DIPJ INTEGER, ADD FICHA VARCHAR(10), ADD DESCRICAO VARCHAR(100)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          lCriouTabela := true;
        except
          begin
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end;

  // Cria tabelas de Formulas
    Tbl.TableName := 'CFORMULAS';
    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_CFORMULAS PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD EMPRESA INTEGER NOT NULL, ADD CODIGO VARCHAR(6) NOT NULL');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD DESCRICAO VARCHAR(50), ADD FORMULA VARCHAR(50)' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          lCriouTabela := true;
        except
          begin
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end;

  // Cria tabela de DRE
    Tbl.TableName := 'CDRE';
    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_CDRE PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD EMPRESA INTEGER, ADD TIPO CHAR(1), ADD CONTA VARCHAR(14), ADD DESCRICAO VARCHAR(70), ADD VALOR NUMERIC(18,2)');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add('ALTER TABLE '+Tbl.TableName+' ADD RECEITA SMALLINT');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add('ALTER TABLE '+Tbl.TableName+' ADD MES01 NUMERIC(18,2), ADD MES02 NUMERIC(18,2), ADD MES03 NUMERIC(18,2), ADD MES04 NUMERIC(18,2), ADD MES05 NUMERIC(18,2), ADD MES06 NUMERIC(18,2)');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add('ALTER TABLE '+Tbl.TableName+' ADD MES07 NUMERIC(18,2), ADD MES08 NUMERIC(18,2), ADD MES09 NUMERIC(18,2), ADD MES10 NUMERIC(18,2), ADD MES11 NUMERIC(18,2), ADD MES12 NUMERIC(18,2)');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD LEI11638 SMALLINT DEFAULT 0' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          lCriouTabela := true;
        except
          begin
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end else begin //Incluido em 23.05.2009
      try
        qry.close;
        qry.SQL.clear;
        qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD LEI11638 SMALLINT DEFAULT 0' );
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        lCriouTabela := true;
      except
      end;
    end;

  // Cria tabela de DRE_COMPARA
    Tbl.TableName := 'CDRE_COMPARA';
    if not Tbl.Exists then begin
      qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID_CDRE_COMPARA INTEGER NOT NULL, CONSTRAINT PK_CDRE_COMPARA PRIMARY KEY(ID_CDRE_COMPARA))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD EMPRESA INTEGER, ADD TIPO CHAR(1), ADD CONTA VARCHAR(14), ADD DESCRICAO VARCHAR(70), ADD VALOR NUMERIC(18,2)');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add('ALTER TABLE '+Tbl.TableName+' ADD RECEITA SMALLINT');
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD LEI11638 SMALLINT DEFAULT 0' );
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          lCriouTabela := true;
        except
          begin
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end;


    // Cria tabela de LOCAIS
      Tbl.TableName := 'PLOCAIS_DOS';
      if not Tbl.Exists then begin
        qry.Close;
        qry.SQL.Clear;
        qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_PLOCAIS_DOS PRIMARY KEY(ID))');
        try
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          try
            qry.close;
            qry.SQL.clear;
            qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD EMPRESA INTEGER NOT NULL, ADD CODIGO INTEGER NOT NULL, ADD DESCRICAO VARCHAR(50)');
//            qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD EMPRESA INTEGER NOT NULL, ADD DESCRICAO VARCHAR(50)');
            qry.ExecSQL;

            qry.close;
            qry.SQL.clear;
            qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD CCUSTO INTEGER, ADD FILIAL INTEGER');
            qry.ExecSQL;
            qry.close;
            qry.SQL.clear;
            lCriouTabela := true;
          except
            begin
              result := false;
            end;
          end;
        except
          begin
            result := false;
          end;
        end;
      end;
    // Cria tabela de PROVENTOS
      Tbl.TableName := 'PROVENTOS';
      if not Tbl.Exists then begin
        qry.Close;
        qry.SQL.Clear;
        qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_PROVENTOS PRIMARY KEY(ID))');
        try
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          try
            qry.close;
            qry.SQL.clear;
            qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD CODIGO CHAR(4) NOT NULL, ADD DESCRICAO VARCHAR(50) NOT NULL');
            qry.ExecSQL;
            qry.close;
            qry.SQL.clear;
            qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD CONTA_DEB VARCHAR(14), ADD CONTA_CRE VARCHAR(14), ADD HISTORICO INTEGER');
            qry.ExecSQL;
            qry.close;
            qry.SQL.clear;
            qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD LEI11638 BOOLEAN');
            qry.ExecSQL;
            qry.close;
            qry.SQL.clear;
            lCriouTabela := true;
          except
            begin
              result := false;
            end;
          end;
        except
          begin
            result := false;
          end;
        end;
      end;
    // Cria tabela de LOCAL_PROVENTOS
      Tbl.TableName := 'LOCAL_PROVENTOS';
      if not Tbl.Exists then begin
        qry.Close;
        qry.SQL.Clear;
        qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_LOCAL_PROVENTOS PRIMARY KEY(ID))');
        try
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          try
            qry.close;
            qry.SQL.clear;
            qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD COD_LOCAL INTEGER NOT NULL, ADD COD_PROVENTO CHAR(4) NOT NULL, ADD EMPRESA INTEGER NOT NULL');
            qry.ExecSQL;
            qry.close;
            qry.SQL.clear;
            qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD CONTA_DEB VARCHAR(14), ADD CONTA_CRE VARCHAR(14), ADD HISTORICO INTEGER');
            qry.ExecSQL;
            qry.close;
            qry.SQL.clear;
            qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD LEI11638 BOOLEAN');
            qry.ExecSQL;
            qry.close;
            qry.SQL.clear;
            lCriouTabela := true;
          except
            begin
              result := false;
            end;
          end;
        except
          begin
            result := false;
          end;
        end;
      end;
    // Cria tabela de PROVISAO
      Tbl.TableName := 'PROVISAO';
      if not Tbl.Exists then begin
        qry.Close;
        qry.SQL.Clear;
        qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_PROVISAO PRIMARY KEY(ID))');
        try
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          try
            qry.close;
            qry.SQL.clear;
            qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD CODIGO INTEGER NOT NULL, ADD DESCRICAO VARCHAR(50)');
            qry.ExecSQL;
            qry.close;
            qry.SQL.clear;
            qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD CONTA_DEB VARCHAR(14), ADD CONTA_CRE VARCHAR(14), ADD HISTORICO INTEGER');
            qry.ExecSQL;
            qry.close;
            qry.SQL.clear;
            qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD LEI11638 BOOLEAN');
            qry.ExecSQL;
            qry.close;
            qry.SQL.clear;
            lCriouTabela := true;
          except
            begin
              result := false;
            end;
          end;
        except
          begin
            result := false;
          end;
        end;
      end;
    // Cria tabela de LOCAL_PROVISAO
      Tbl.TableName := 'LOCAL_PROVISAO';
      if not Tbl.Exists then begin
        qry.Close;
        qry.SQL.Clear;
        qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_LOCAL_PROVISAO PRIMARY KEY(ID))');
        try
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          try
            qry.close;
            qry.SQL.clear;
            qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD COD_LOCAL INTEGER NOT NULL, ADD COD_PROVISAO INTEGER NOT NULL, ADD EMPRESA INTEGER NOT NULL');
            qry.ExecSQL;
            qry.close;
            qry.SQL.clear;
            qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD CONTA_DEB VARCHAR(14), ADD CONTA_CRE VARCHAR(14), ADD HISTORICO INTEGER NOT NULL');
            qry.ExecSQL;
            qry.close;
            qry.SQL.clear;
            qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD LEI11638 BOOLEAN');
            qry.ExecSQL;
            qry.close;
            qry.SQL.clear;
            lCriouTabela := true;
          except
            begin
              result := false;
            end;
          end;
        except
          begin
            result := false;
          end;
        end;
      end;
    // Cria tabela de TEMP_INT_PESSOAL
      Tbl.TableName := 'TEMP_INT_PESSOAL';
      if not Tbl.Exists then begin
        qry.Close;
        qry.SQL.Clear;
        qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_TMP_INT_PESSOAL PRIMARY KEY(ID))');
        try
          qry.ExecSQL;
          qry.close;
          qry.SQL.clear;
          try
            qry.close;
            qry.SQL.clear;
            qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD DATA TIMESTAMP NOT NULL, ADD EMPRESA INTEGER NOT NULL, ADD COD_LOCAL INTEGER, ADD LOCAL VARCHAR(14)');
            qry.ExecSQL;
            qry.close;
            qry.SQL.clear;
            qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD MATRICULA INTEGER, ADD CCUSTO INTEGER, ADD FILIAL INTEGER');
            qry.ExecSQL;
            qry.close;
            qry.SQL.clear;
            qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD TIPO CHAR(1) NOT NULL, ADD CONTA_DEB VARCHAR(14), ADD CONTA_CRE VARCHAR(14), ADD COD_HISTORICO INTEGER NOT NULL, ADD COMPL VARCHAR(500)');
            qry.ExecSQL;
            qry.close;
            qry.SQL.clear;
            qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD BASE_CALCULO NUMERIC(18,2), ADD VALOR NUMERIC(18,2) NOT NULL, ADD INSS SMALLINT, ADD COD_PROVENTO CHAR(4), ADD COD_PROVISAO INTEGER, ADD ORIGEM VARCHAR(8)');
            qry.ExecSQL;
            qry.close;
            qry.SQL.clear;
            lCriouTabela := true;
          except
            begin
              result := false;
            end;
          end;
        except
          begin
            result := false;
          end;
        end;
      end;
//    end;

  //Este Commit grava fisicamente as tabelas criadas.
    if lCriouTabela then begin
      IBTransaction.CommitRetaining;
    end;


    //Cria índices
    try
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add('CREATE DESCENDING INDEX CLANCAMENTOS_CDHIST ON CLANCAMENTOS (EMPRESA,DATA,CDHIST)');
      Qry.ExecSQL;

      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add('CREATE INDEX IDX_CBACKUP_EMPRESA ON CBACKUP (EMPRESA)');
      Qry.ExecSQL;

      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add('CREATE INDEX IDX_CCM_DP_PERMANENTE_EMPRESA ON CCM_DP_PERMANENTE (EMPRESA)');
      Qry.ExecSQL;

      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add('CREATE INDEX IDX_CCONTAS_LALUR_PARTE_B_EMPRE ON CCONTAS_LALUR_PARTE_B (EMPRESA)');
      Qry.ExecSQL;

      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add('CREATE INDEX IDX_CCTNEG_EMPRESA ON CCTNEG (EMPRESA)');
      Qry.ExecSQL;

      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add('CREATE INDEX IDX_CCUSTOS_EMPRESA ON CCUSTOS (EMPRESA)');
      Qry.ExecSQL;

      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add('CREATE INDEX IDX_CDATAS_ERROR_EMPRESA ON CDATAS_ERROR (EMPRESA)');
      Qry.ExecSQL;

      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add('CREATE INDEX IDX_CDRE_EMRPESA ON CDRE (EMPRESA)');
      Qry.ExecSQL;

      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add('CREATE INDEX IDX_CFILIAIS_EMRPESA ON CFILIAIS (EMPRESA)');
      Qry.ExecSQL;

      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add('CREATE INDEX IDX_CFORMULAS_EMPRESA ON CFORMULAS (EMPRESA)');
      Qry.ExecSQL;

      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add('CREATE INDEX IDX_CGRUPOS_PERMANENTE_EMPRESA ON CGRUPOS_PERMANENTE (EMPRESA)');
      Qry.ExecSQL;

      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add('CREATE INDEX IDX_CLALUR_PARTE_B_EMPRESA ON CLALUR_PARTE_B (EMPRESA)');
      Qry.ExecSQL;

      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add('CREATE INDEX IDX_CLANCAM_IMOB_EMPRESA ON CLANCAM_IMOB (EMPRESA)');
      Qry.ExecSQL;

      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add('CREATE INDEX IDX_CLANCCAIXA_EMPRESA ON CLANCCAIXA (EMPRESA)');
      Qry.ExecSQL;

      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add('CREATE INDEX IDX_CLOTES_ERROR_EMPRESA ON CLOTES_ERROR (EMPRESA)');
      Qry.ExecSQL;

      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add('CREATE INDEX IDX_CM_CC_PL_EMPRESA ON CM_CC_PL (EMPRESA)');
      Qry.ExecSQL;

      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add('CREATE INDEX IDX_CSDOCAIXA_EMPRESA ON CSDOCAIXA (EMPRESA)');
      Qry.ExecSQL;

      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add('CREATE INDEX IDX_CSOCIOS_EMPRESA ON CSOCIOS (EMPRESA)');
      Qry.ExecSQL;

      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add('CREATE UNIQUE INDEX IDX_CSALDO_CONTAS ON CSALDO_CONTAS (EMPRESA, DATA, CONTA, HIST62, FILIAL, CCUSTO)');
      Qry.ExecSQL;

      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add('CREATE UNIQUE INDEX IDX_CLOTES_ILOTES ON CLOTES (EMPRESA, ANO, LOTE)');
      Qry.ExecSQL;

      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add('CREATE UNIQUE INDEX PROVISAO_iCodigo ON PROVISAO(CODIGO,LEI11638)');
      Qry.ExecSQL;

      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add('CREATE UNIQUE INDEX PROVENTOS_iCodigo ON PROVENTOS(CODIGO,LEI11638)');
      Qry.ExecSQL;

      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add('CREATE UNIQUE INDEX LOCAL_PROVISAO_iCodigo ON LOCAL_PROVISAO(EMPRESA,COD_LOCAL,COD_PROVISAO,LEI11638)');
      Qry.ExecSQL;

      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add('CREATE UNIQUE INDEX LOCAL_PROVENTOS_iCodigo ON LOCAL_PROVENTOS(EMPRESA,COD_LOCAL,COD_PROVENTO,LEI11638)');
      Qry.ExecSQL;

//      Qry.Close;
//      Qry.SQL.Clear;
//      Qry.SQL.Add('CREATE UNIQUE INDEX CSALDO_CONTAS_iEMPCONTA ON CSALDO_CONTAS(EMPRESA,CONTA,DATA,FILIAL,CCUSTO,HIST62)');
//      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add('CREATE UNIQUE INDEX CPLANOGERAL_iCODREDUZ ON CPLANOGERAL(CODREDUZ,LEI11638)');
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE UNIQUE INDEX CPLANOEMPRESA_iCODREDUZ ON CPLANOEMPRESA(EMPRESA,CODREDUZ,LEI11638)');
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add('CREATE INDEX CLANCAMENTOS_RAZAO ON CLANCAMENTOS (EMPRESA,CCUSTO,FILIAL,DATA,CONTA_DEB,CONTA_CRE)');
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add('CREATE INDEX CLANCAMENTOS_DT_CONTA ON CLANCAMENTOS (EMPRESA,DATA,CONTA_DEB,CONTA_CRE)');
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add('CREATE UNIQUE INDEX CPLANOEMPRESA_ICONTA ON CPLANOEMPRESA (EMPRESA,CONTA,LEI11638)');
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add('CREATE UNIQUE INDEX CPLANOGERAL_ICONTA ON CPLANOGERAL (CONTA,LEI11638)');
      Qry.ExecSQL;
      Qry.Close;

      Qry.SQL.Clear;
      Qry.SQL.Add('CREATE UNIQUE INDEX CLANCAMENTOS_LANCAMENTOS ON CLANCAMENTOS (EMPRESA,ANO,LOTE,LINHA)');
      Qry.ExecSQL;

  //    Qry.Close;
  //    Qry.SQL.Clear;
  //    Qry.SQL.Add( 'CREATE INDEX CLANCAMENTOS_iCONTA_DEB ON CLANCAMENTOS(EMPRESA,CONTA_DEB,DATA)' );
  //    Qry.ExecSQL;
  //    Qry.SQL.Add( 'CREATE INDEX CLANCAMENTOS_iCONTA_CRE ON CLANCAMENTOS(EMPRESA,CONTA_CRE,DATA)' );
  //    Qry.ExecSQL;
  //    Qry.Close;
  //    Qry.SQL.Clear;
  //    Qry.SQL.Add( 'CREATE INDEX CLANCAMENTOS_iDATA ON CLANCAMENTOS(EMPRESA,DATA)' );
  //    Qry.ExecSQL;
  //    Qry.Close;
  //    Qry.SQL.Clear;
    except
      Qry.Close;
      Qry.SQL.Clear;
    end;

    {Cria A view de lancamentos com a soma por mes das contas a debito e
    credito. Esta view é utilizada pela consulta ao plano de contas}
    try
      qry.close;
      qry.SQL.clear;
      qry.SQL.Add('CREATE VIEW VIEW_LANCAM(EMPRESA, ANO, MES, CONTA_DEB, CONTA_CRE, CCUSTO, FILIAL, VALOR) AS SELECT EMPRESA, ANO, EXTRACT(MONTH FROM DATA) AS MES, CONTA_DEB, CONTA_CRE, CCUSTO, FILIAL, VALOR FROM CLANCAMENTOS');
      qry.ExecSQL;
      qry.close;
      qry.SQL.clear;
    except
      Qry.Close;
      Qry.SQL.Clear;
    end;

    //Cria os Generators
    try
      //LOCAL_PROVENTO
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_LOCAL_PROVENTOS' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_LOCAL_PROVENTOS TO 0' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;

      //PROVENTOS
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_PROVENTOS' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_PROVENTOS TO 0' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;

      //LOCAL_PROVISAO
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_LOCAL_PROVISAO' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_LOCAL_PROVISAO TO 0' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;

      //PROVISAO
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_PROVISAO' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_PROVISAO TO 0' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;

      //TEMP_INT_PESSOAL
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_TEMP_INT_PESSOAL' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_TEMP_INT_PESSOAL TO 0' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      //PLOCAIS
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_PLOCAIS_DOS' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_PLOCAIS_DOS TO 0' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;


      //CCONTAS_LALUR_PARTE_B
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_CCONTAS_LALUR_PARTE_B' );
      Qry.ExecSQL;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_CCONTAS_LALUR_PARTE_B TO 0' );
      Qry.ExecSQL;
      //CLALUR_PARTE_B
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_CLALUR_PARTE_B' );
      Qry.ExecSQL;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_CLALUR_PARTE_B TO 0' );
      Qry.ExecSQL;
    except
    end;

    try
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'DROP GENERATOR GEN_ID_LOCAL_PROVENTO' );
      Qry.ExecSQL;
    except
    end;

    try
      //CDRE
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_CSALDO_CONTAS' );
      Qry.ExecSQL;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_CSALDO_CONTAS TO 0' );
      Qry.ExecSQL;
    except
    end;
    try
      //CDRE
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_CDRE' );
      Qry.ExecSQL;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_CDRE TO 0' );
      Qry.ExecSQL;
    except
    end;
    try
      //CFICHAS_IR
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_CFICHAS_IR' );
      Qry.ExecSQL;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_CFICHAS_IR TO 0' );
      Qry.ExecSQL;
    except
    end;
    try
      //CBACKUP
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_CBACKUP' );
      Qry.ExecSQL;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_CBACKUP TO 0' );
      Qry.ExecSQL;
    except
    end;
    try
      //CBAIXA PERMANENTE
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_CBAIXA_PERMANENTE' );
      Qry.ExecSQL;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_CBAIXA_PERMANENTE TO 0' );
      Qry.ExecSQL;
    except
    end;
    try
      //CBENS PERMANENTE
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_CBENS_PERMANENTE' );
      Qry.ExecSQL;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_CBENS_PERMANENTE TO 0' );
      Qry.ExecSQL;
    except
    end;
    try
      //CCM DP PERMANENTE
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_CCM_DP_PERMANENTE' );
      Qry.ExecSQL;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_CCM_DP_PERMANENTE TO 0' );
      Qry.ExecSQL;
    except
    end;
    try
      //CCTNEG
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_CCTNEG' );
      Qry.ExecSQL;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_CCTNEG TO 0' );
      Qry.ExecSQL;
    except
    end;
    try
      //CCUSTOS
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_CCUSTOS' );
      Qry.ExecSQL;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_CCUSTOS TO 0' );
      Qry.ExecSQL;
    except
    end;
    try
      //CDATAS_ERROR
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_CDATAS_ERROR' );
      Qry.ExecSQL;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_CDATAS_ERROR TO 0' );
      Qry.ExecSQL;
    except
    end;
    try
      //CFILIAIS
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_CFILIAIS' );
      Qry.ExecSQL;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_CFILIAIS TO 0' );
      Qry.ExecSQL;
    except
    end;
    try
      //CFORMULAS
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_CFORMULAS' );
      Qry.ExecSQL;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_CFORMULAS TO 0' );
      Qry.ExecSQL;
    except
    end;
    try
      //CGRUPOS_PERMANENTE
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_CGRUPOS_PERMANENTE' );
      Qry.ExecSQL;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_CGRUPOS_PERMANENTE TO 0' );
      Qry.ExecSQL;
    except
    end;
    try
      //CGRUPOS_PERMANENTE
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_CINTEGRA' );
      Qry.ExecSQL;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_CINTEGRA TO 0' );
      Qry.ExecSQL;
    except
    end;
    try
      //CLANCAMENTOS
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_CLANCAMENTOS' );
      Qry.ExecSQL;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_CLANCAMENTOS TO 0' );
      Qry.ExecSQL;
    except
    end;
    try
      //CLANCAM IMOB
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_CLANCAM_IMOB' );
      Qry.ExecSQL;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_CLANCAM_IMOB TO 0' );
      Qry.ExecSQL;
    except
    end;
    try
      //CLANCCAIXA
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_CLANCCAIXA' );
      Qry.ExecSQL;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_CLANCCAIXA TO 0' );
      Qry.ExecSQL;
    except
    end;
    try
      //CLOTES
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_CLOTES' );
      Qry.ExecSQL;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_CLOTES TO 0' );
      Qry.ExecSQL;
    except
    end;
    try
      //CLOTES_ERROR
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_CLOTES_ERROR' );
      Qry.ExecSQL;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_CLOTES_ERROR TO 0' );
      Qry.ExecSQL;
    except
    end;
    try
      //CM CC PL
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_CM_CC_PL' );
      Qry.ExecSQL;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_CM_CC_PL TO 0' );
      Qry.ExecSQL;
    except
    end;
    try
      //CPARAMETROS
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_CPARAMETROS' );
      Qry.ExecSQL;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_CPARAMETROS TO 0' );
      Qry.ExecSQL;
    except
    end;
    try
      //CPLANO EMPRESA
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_CPLANOEMPRESA' );
      Qry.ExecSQL;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_CPLANOEMPRESA TO 0' );
      Qry.ExecSQL;
    except
    end;
    try
      //CPLANO GERAL
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_CPLANOGERAL' );
      Qry.ExecSQL;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_CPLANOGERAL TO 0' );
      Qry.ExecSQL;
    except
    end;
    try
      //CPLANO HISTORICO
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_CPLANOHISTORICO' );
      Qry.ExecSQL;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_CPLANOHISTORICO TO 0' );
      Qry.ExecSQL;
    except
    end;
    try
      //CSDOCAIXA
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_CSDOCAIXA' );
      Qry.ExecSQL;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_CSDOCAIXA TO 0' );
      Qry.ExecSQL;
    except
      Qry.Close;
      Qry.SQL.Clear;
  //  Não faz nada
    end;
    Qry.Close;
    Qry.SQL.Clear;

    {
    //Generator para Lançamentos de caixa
    Try
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_CLANCAM_CAIXA' );
      Qry.ExecSQL;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_CLANCAM_CAIXA TO 0' );
      Qry.ExecSQL;
    except
      Qry.Close;
      Qry.SQL.Clear;
  //  Não faz nada
    end;

    //Generator para DRE
    Try
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_DRE' );
      Qry.ExecSQL;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_DRE TO 0' );
      Qry.ExecSQL;
    except
      Qry.Close;
      Qry.SQL.Clear;
  //  Não faz nada
    end;
    }
    try
      IBTransaction.CommitRetaining;
    except
    end;

    try
      Qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add('alter table CPLANOGERAL_DESCRICAO Add constraint FK_CPLANOGERAL_DESCRICAO foreign key (FK_CPLANOGERAL) references CPLANOGERAL(ID_CPLANOGERAL)');
      QRY.ExecSQL;

      Qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add('alter table CPLANOEMPRESA_DESCRICAO Add constraint FK_CPLANOEMPRESA_DESCRICAO foreign key (FK_CPLANOEMPRESA) references CPLANOEMPRESA(ID_CPLANOEMPRESA)');
      QRY.ExecSQL;
    except
    end;

    try
      Qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add('CREATE UNIQUE INDEX IDX_CPLANOGERAL_DESCRICAO_DATA ON CPLANOGERAL_DESCRICAO (DATA,FK_CPLANOGERAL)');
      QRY.ExecSQL;

      Qry.Close;
      qry.SQL.Clear;
      qry.SQL.Add('CREATE UNIQUE INDEX IDX_CPLANOEMPRESA_DESC_DATA ON CPLANOEMPRESA_DESCRICAO (DATA,FK_CPLANOEMPRESA)');
      QRY.ExecSQL;
    except
    end;

    try
      IBTransaction.CommitRetaining;
    except
    end;

    Qry.Close;
    Qry.Free;
    Tbl.Close;
    Tbl.Free;
  finally
    IBDataBase.Connected := false;
    IBTransaction.Active := false;
    IBDataBase.Free;
    IBTransaction.Free;
  end;
end;

{Cria e preenche as tabelas do programa pessoal que serão utilizadas
pelo PPP}
function CriaTabPessoalPPP(sPath:string): Boolean;
var
  qry : TIBQuery;
  Tbl : TIBTable;
  IBDataBase : TIBDataBase;
  IBTransaction : TIBTransaction;
  lCriouTabela : boolean;
begin
  result := true;
  lCriouTabela := false;
  IBDataBase := TIBDataBase.Create(nil);
  IBTransaction := TIBTransaction.Create(nil);
  IBTransaction.DefaultDatabase := IBDataBase;
  IBTransaction.Params.Add('read_committed');
  IBTransaction.Params.Add('rec_version');
  IBTransaction.Params.Add('nowait');
  IBDataBase.DefaultTransaction := IBTransaction;
  IBDataBase.AllowStreamedConnected := false;
  IBDataBase.Connected := false;
  IBDataBase.DatabaseName := sPath;
  IBDataBase.DefaultTransaction := IBTransaction;
  IBDataBase.LoginPrompt := false;
  IBDataBase.Params.Clear;
  IBDataBase.Params.Add( 'user_name=SYSDBA' );
  IBDataBase.Params.Add( 'password=masterkey' );
  IBDataBase.SQLDialect := 3;
  try
    try
      IBDataBase.Connected := true;
    except
      IBDataBase.Params.Clear;
      IBDataBase.Params.Add( 'USER "SYSDBA"' );
      IBDataBase.Params.Add( 'PASSWORD "masterkey"' );
      try
        IBDataBase.CreateDatabase;
        IBDataBase.Connected := true;
      except
        Result := false;
        Exit;
      end;
    end;
    Tbl := TIBTable.Create(nil);
    Tbl.Database := IBDataBase;
    qry := TIBQuery.Create(nil);
    qry.Database := IBDataBase;

    Tbl.TableName := 'PTIPOS';
    if not Tbl.Exists then begin
      qry.SQL.clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID_PTIPOS INTEGER NOT NULL, CONSTRAINT PK_PTIPOS PRIMARY KEY(ID_PTIPOS))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD TIPO SMALLINT NOT NULL, ADD CODIGO SMALLINT NOT NULL, ADD SUBCODIGO SMALLINT, ADD DESCRICAO VARCHAR(200) NOT NULL');
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD TIPO_FGTS VARCHAR(2)');
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD UNICO SMALLINT');
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        lCriouTabela := true;
      except
        result := false;
      end;
    end;
  // Cria tabela de CBO
    Tbl.TableName := 'PCBO';
    if not Tbl.Exists then begin
      qry.close;
      qry.SQL.clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID_PCBO INTEGER NOT NULL, CONSTRAINT PK_PCBO PRIMARY KEY(ID_PCBO))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD CBO VARCHAR(6) NOT NULL, ADD DESCRICAO VARCHAR(200) NOT NULL');
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        lCriouTabela := true;
      except
        begin
          result := false;
        end;
      end;
    end;
    {Cria os Generators}
    try
      //CBO
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_PCBO' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_PCBO TO 0' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      //PTIPOS
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_PTIPOS' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_PTIPOS TO 0' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
    except
      Qry.Close;
      Qry.SQL.Clear;
    end;

  //Este Commit grava fisicamente as tabelas criadas.
    if lCriouTabela then begin
      IBTransaction.CommitRetaining;
    end;

    Qry.Close;
    Qry.Free;
    Tbl.Close;
    Tbl.Free;
  finally
    IBDataBase.Connected := false;
    IBTransaction.Active := false;
    IBDataBase.Free;
    IBTransaction.Free;
  end;
end;

//Cria tabelas Gerente
function CriaTabFinanceiro(sPath:string): Boolean;
var
  qry : TIBQuery;
  Tbl : TIBTable;
  IBDataBase : TIBDataBase;
  IBTransaction : TIBTransaction;
  lCriouTabela : boolean;
begin
  result := true;
  lCriouTabela := false;
  IBDataBase := TIBDataBase.Create(nil);
  IBTransaction := TIBTransaction.Create(nil);
  IBTransaction.DefaultDatabase := IBDataBase;
  IBTransaction.Params.Add('read_committed');
  IBTransaction.Params.Add('rec_version');
  IBTransaction.Params.Add('nowait');
  IBDataBase.DefaultTransaction := IBTransaction;
  IBDataBase.AllowStreamedConnected := false;
  IBDataBase.Connected := false;
  IBDataBase.DatabaseName := sPath;
  IBDataBase.DefaultTransaction := IBTransaction;
  IBDataBase.LoginPrompt := false;
  IBDataBase.Params.Clear;
  IBDataBase.Params.Add( 'user_name=SYSDBA' );
  IBDataBase.Params.Add( 'password=masterkey' );
  IBDataBase.SQLDialect := 3;
  try
    try
      IBDataBase.Connected := true;
    except
      IBDataBase.Params.Clear;
      IBDataBase.Params.Add( 'USER "SYSDBA"' );
      IBDataBase.Params.Add( 'PASSWORD "masterkey"' );
      try
        IBDataBase.CreateDatabase;
        IBDataBase.Connected := true;
      except
        Result := false;
        Exit;
      end;
    end;
    Tbl := TIBTable.Create(nil);
    Tbl.Database := IBDataBase;
    qry := TIBQuery.Create(nil);
    qry.Database := IBDataBase;

  // Cria tabela de Bancos
    Tbl.TableName := 'BCO';
    if not Tbl.Exists then begin
      qry.close;
      qry.SQL.clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_BCO PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        try
          qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD CODIGO INTEGER NOT NULL, ADD DESCRICAO VARCHAR(50) NOT NULL');
          qry.ExecSQL;
          qry.close;
          lCriouTabela := true;
        except
          begin
            result := false;
          end;
        end;
      except
        begin
          result := false;
        end;
      end;
    end;

  // Cria tabela de Agencias Bancárias
    Tbl.TableName := 'BCO_AGE';
    if not Tbl.Exists then begin
      qry.close;
      qry.SQL.clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_BCO_AGE PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD ID_BCO INTEGER NOT NULL, ADD COD_AGENCIA INTEGER NOT NULL, ADD DG_COD_AGENCIA VARCHAR(2), ADD DESCRICAO VARCHAR(50) NOT NULL');
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        lCriouTabela := true;
      except
        begin
          result := false;
        end;
      end;
    end;

  // Cria tabela de Contas-Correntes Bancárias
    Tbl.TableName := 'AGE_CC';
    if not Tbl.Exists then begin
      qry.close;
      qry.SQL.clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_AGE_CC PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD ID_BCO_AGE INTEGER NOT NULL, ADD CONTA VARCHAR(15) NOT NULL, ADD DIGITO VARCHAR(2) NOT NULL, ADD TITULAR VARCHAR(50) NOT NULL, ADD INSCMF INSCMF');
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD CODIGO_CEDENTE VARCHAR(10) NOT NULL, ADD DG_COD_CEDENTE CHAR(1) NOT NULL');
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        lCriouTabela := true;
      except
        begin
          result := false;
        end;
      end;
    end;

  // Cria tabela de Contas-Correntes Bancárias - Lançamentos
    Tbl.TableName := 'CC_LANCAM';
    if not Tbl.Exists then begin
      qry.close;
      qry.SQL.clear;
      qry.SQL.Add( 'CREATE TABLE '+Tbl.TableName+' (ID INTEGER NOT NULL, CONSTRAINT PK_CC_LANCAM PRIMARY KEY(ID))');
      try
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
//        qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD ID_AGE_CC INTEGER NOT NULL, ADD DATA NOT NULL, ADD COD_HISTORICO INTEGER NOT NULL, ADD VALOR NUMERIC(18,2) NOT NULL, ADD TIPO SMALLINT NOT NULL CHECK ((VALUE >= 1) AND (VALUE <=2)), ADD DT_EXTRATO DATE');
        qry.SQL.Add( 'ALTER TABLE ' + Tbl.TableName + ' ADD ID_AGE_CC INTEGER NOT NULL, ADD DATA DATE NOT NULL, ADD COD_HISTORICO INTEGER NOT NULL, ADD VALOR NUMERIC(18,2) NOT NULL, ADD TIPO SMALLINT NOT NULL, ADD DT_EXTRATO DATE');
        qry.ExecSQL;
        qry.close;
        qry.SQL.clear;
        lCriouTabela := true;
      except
        begin
          result := false;
        end;
      end;
    end;

    {Cria os Generators}
    try
      //GEN ID BANCO
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_BCO' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_BCO TO 0' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      //GEN ID BCO_AGE
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_BCO_AGE' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_BCO_AGE TO 0' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      //GEN ID AGE_CC
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_AGE_CC' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_AGE_CC TO 0' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      //GEN ID CC_LANCAM
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'CREATE GENERATOR GEN_ID_CC_LANCAM' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
      Qry.SQL.Add( 'SET GENERATOR GEN_ID_CC_LANCAM TO 0' );
      Qry.ExecSQL;
      Qry.Close;
      Qry.SQL.Clear;
    except
      Qry.Close;
      Qry.SQL.Clear;
    end;

  //Este Commit grava fisicamente as tabelas criadas.
    if lCriouTabela then begin
      IBTransaction.CommitRetaining;
    end;

    {Cria as chaves estrangeiras para pcadastro_funcionario}
    try
      qry.close;
      qry.SQL.clear;
      qry.SQL.Add( 'ALTER TABLE BCO_AGE ADD CONSTRAINT FK_BCO_AGE FOREIGN KEY (ID_BCO) REFERENCES BCO(ID)');
      qry.ExecSQL;
      qry.close;
      qry.SQL.clear;
      qry.SQL.Add( 'ALTER TABLE AGE_CC ADD CONSTRAINT FK_AGE_CC FOREIGN KEY (ID_BCO_AGE) REFERENCES BCO_AGE(ID)');
      qry.ExecSQL;
      qry.close;
      qry.SQL.clear;
      qry.SQL.Add( 'ALTER TABLE CC_LANCAM ADD CONSTRAINT FK_CC_LANCAM FOREIGN KEY (ID_AGE_CC) REFERENCES AGE_CC(ID)');
      qry.ExecSQL;
      qry.close;
      qry.SQL.clear;
    except
      qry.close;
      qry.SQL.clear;
    end;

    Qry.Close;
    Qry.Free;
    Tbl.Close;
    Tbl.Free;
  finally
    IBDataBase.Connected := false;
    IBTransaction.Active := false;
    IBDataBase.Free;
    IBTransaction.Free;
  end;
end;

//Criptografia
function Encrypt(InString: String): String;
var
  str_local, str_result: String;
begin
{$R-}
{$Q-}
  str_local  := InString;
  str_result := BinaryMethod(str_local,StartKey);
  Result := str_result;
{$R+}
{$Q+}
end;

function Decrypt(InString: String): String;
var
  str_local, str_result: String;
begin
{$R-}
{$Q-}
  str_local  := InString;
  str_result := BinaryMethod(str_local,StartKey);
  Result := str_result;
{$R+}
{$Q+}
end;

function BinaryMethod(const aText: string; aKey: word): string;
var
   nInd: Integer;
begin
   Result := aText;
   aKey := aKey shr 8;
   if aKey = 0 then
     exit;
   for nInd := 1 to length(Result) do
     Result[nInd] := char(byte(Result[nInd]) xor aKey);
end;


Function fCripto( sLinha:String ):string;
var
  sNovaLin : string;
  i : integer;
  cLetra : char;
begin
  for i := 1 to length( sLinha ) do begin
    cLetra := sLinha[i];
//    cLetra := System.Chr(System.Ord(cLetra)+102);
//    cLetra := System.Chr(System.Ord(cLetra)+35);
    cLetra := System.Chr(System.Ord(cLetra)+5);
    sNovaLin := sNovaLin + cLetra;
  end;
  result := sNovaLin;
end;

Function fDeCripto( sLinha : String ):string;
var
  sNovaLin : string;
  i : integer;
  cLetra : char;
begin
  sNovaLin := '';
  For i := 1 to Length( sLinha ) do begin
    cLetra := sLinha[i];
//    cLetra := System.Chr(System.Ord(cLetra)-102);
//    cLetra := System.Chr(System.Ord(cLetra)-35);
    cLetra := System.Chr(System.Ord(cLetra)-5);
    sNovaLin := sNovaLin + cLetra;
  end;
  result := sNovaLin;
end;

//Datas - Feriados
{*******************************************}
// CALCULO DA PASCOA
{*******************************************}
function CalculaPascoa(AAno: Word): TDateTime;
var
  R1, R2, R3, R4, R5 : Longint;
  FPascoa : TDateTime;
  VJ, VM, VD : Word;
begin
  R1 := AAno mod 19;
  R2 := AAno mod 4;
  R3 := AAno mod 7;
  R4 := (19 * R1 + 24) mod 30;
  R5 := (6 * R4 + 4 * R3 + 2 * R2 + 5) mod 7;

  FPascoa := EncodeDate(AAno, 3, 22);
  FPascoa := FPascoa + R4 + R5;

  DecodeDate(FPascoa, VJ, VM, VD);
  case VD of
    26 : FPascoa := EncodeDate(Aano, 4, 19);
    25 : if R1 > 10 then
           FPascoa := EncodeDate(AAno, 4, 18);
  end;

  Result:= FPascoa;
end;

function CalculaFeriado(AAno: Word; ATipo: TFeriados): TDate;
var
  Aux: TDate;
begin
  Aux := CalculaPascoa(AAno);
  Case ATipo of
    frCarnaval : Aux := Aux - 47;
    frQuartaCinzas : Aux := Aux - 46;
    frSextaSanta : Aux := Aux - 2;
    frCorpusChristi: Aux := Aux + 60;
  end;
  Result := Aux;
end;

function fGravaFeriados(pbAtualiza: Boolean = False): Boolean; {Grava ou atualiza a tabela com todos os feriados nacionais móveis e fixos de 1980 a 2050}
var
  loQryFeriados: TFDQuery;
  laTipo : TFeriados;
  laAno : word;
  ldData : TDate;
  liFor : integer;
  liTransacao: LongWord;
  lbContinua: Boolean;
begin
  Result := False;
  loQryFeriados := TFDQuery.Create(nil);
  try
    lbContinua := True;
    if not pbAtualiza then begin
      loQryFeriados.Connection := TUtilConexaoFireDac.getConn;
      loQryFeriados.SQL.Append('SELECT FIRST 1 DATA FROM FERIADOS');
      loQryFeriados.Open;
      if not loQryFeriados.IsEmpty then begin
        lbContinua := False;
      end;
    end;

    if lbContinua then begin
      loQryFeriados.Close;
      loQryFeriados.SQL.Clear;
      loQryFeriados.SQL.Append('UPDATE OR INSERT INTO FERIADOS (ID_FERIADOS,DATA,DESCRICAO) VALUES(CREATEGUID(),:pData,:pDescricao) MATCHING (ID_FERIADOS)');
      liTransacao := IncLongWord(rInfoConexao.iTransacao);
      TUtil.StartTransaction(TUtil.getConn,liTransacao);

      for liFor := 1980 to 2050 do begin
        laAno := liFor;
        laTipo := frCarnaval;
        ldData := CalculaFeriado(laAno, lATipo);
//        loQryFeriados.ParamByName('pIdFeriados').AsString := '{EBB143CB-A840-43A9-9FE3-346FEDA93E97}';
        loQryFeriados.ParamByName('pData'      ).AsDate   := ldData;
        loQryFeriados.ParamByName('pDescricao'      ).AsString := 'CARNAVAL';
        loQryFeriados.ExecSQL;

//        loQryFeriados.ParamByName('pIdFeriados').AsString := '{0F193AF7-BC0F-4BF9-99B4-943D4495EE9A}';
        loQryFeriados.ParamByName('pData'      ).AsDate   := ldData-1;
        loQryFeriados.ParamByName('pDescricao'      ).AsString := 'CARNAVAL';
        loQryFeriados.ExecSQL;

        laTipo := frPascoa;
        ldData := CalculaFeriado(laAno, lATipo);
//        loQryFeriados.ParamByName('pIdFeriados').AsString := '{4B2196A0-94DB-4A2B-9B7C-8908A492FFEC}';
        loQryFeriados.ParamByName('pData'      ).AsDate   := ldData;
        loQryFeriados.ParamByName('pDescricao'      ).AsString := 'PÁSCOA';
        loQryFeriados.ExecSQL;

        laTipo := frSextaSanta;
        ldData := CalculaFeriado(laAno, lATipo);
//        loQryFeriados.ParamByName('pIdFeriados').AsString := '{21FC94A8-F9A2-45CC-B744-53496838D6FF}';
        loQryFeriados.ParamByName('pData'      ).AsDate   := ldData;
        loQryFeriados.ParamByName('pDescricao'      ).AsString := 'SEXTA-FEIRA SANTA';
        loQryFeriados.ExecSQL;

        laTipo := frCorpusChristi;
        ldData := CalculaFeriado(laAno, lATipo);
//        loQryFeriados.ParamByName('pIdFeriados').AsString := '{3A21042F-4692-46CE-A9D6-A605F9C407EE}';
        loQryFeriados.ParamByName('pData'      ).AsDate   := ldData;
        loQryFeriados.ParamByName('pDescricao'      ).AsString := 'CORPUS CHRISTI';
        loQryFeriados.ExecSQL;

        ldData := StrToDateTime('01/01/'+ IntToStr(liFor));
//        loQryFeriados.ParamByName('pIdFeriados').AsString := '{45C1E4C2-2466-4BC2-81BC-B884A5B8F3CB}';
        loQryFeriados.ParamByName('pData'      ).AsDate   := ldData;
        loQryFeriados.ParamByName('pDescricao'      ).AsString := 'DIA DA CONFRATERNIZAÇÃO UNIVERSAL';
        loQryFeriados.ExecSQL;

        ldData := StrToDateTime('21/04/'+ IntToStr(liFor));
//        loQryFeriados.ParamByName('pIdFeriados').AsString := '{BCC8A9F3-8944-4CF8-B3E9-FB79AF54AE99}';
        loQryFeriados.ParamByName('pData'      ).AsDate   := ldData;
        loQryFeriados.ParamByName('pDescricao'      ).AsString := 'TIRADENTES';
        loQryFeriados.ExecSQL;

        ldData := StrToDateTime('01/05/'+ IntToStr(liFor));
//        loQryFeriados.ParamByName('pIdFeriados').AsString := '{A73957D6-8BF5-4A9A-8F46-7275A808CC4A}';
        loQryFeriados.ParamByName('pData'      ).AsDate   := ldData;
        loQryFeriados.ParamByName('pDescricao'      ).AsString := 'DIA DO TRABALHO';
        loQryFeriados.ExecSQL;

        ldData := StrToDateTime('24/06/'+ IntToStr(liFor));
//        loQryFeriados.ParamByName('pIdFeriados').AsString := '{824D5B64-BB0B-4B29-911B-19E467A3530D}';
        loQryFeriados.ParamByName('pData'      ).AsDate   := ldData;
        loQryFeriados.ParamByName('pDescricao'      ).AsString := 'SÃO JOÃO';
        loQryFeriados.ExecSQL;

        ldData := StrToDateTime('02/07/'+ IntToStr(liFor));
//        loQryFeriados.ParamByName('pIdFeriados').AsString := '{393ECBE2-B89B-4612-97C0-A003A52059B2}';
        loQryFeriados.ParamByName('pData'      ).AsDate   := ldData;
        loQryFeriados.ParamByName('pDescricao'      ).AsString := 'INDEPENDÊNCIA DA BAHIA';
        loQryFeriados.ExecSQL;

        ldData := StrToDateTime('07/09/'+ IntToStr(liFor));
//        loQryFeriados.ParamByName('pIdFeriados').AsString := '{0AA05C27-29FA-4517-98ED-61B6CA927822}';
        loQryFeriados.ParamByName('pData'      ).AsDate   := ldData;
        loQryFeriados.ParamByName('pDescricao'      ).AsString := 'INDEPENDÊNCIA DO BRASIL';
        loQryFeriados.ExecSQL;

        ldData := StrToDateTime('12/10/'+ IntToStr(liFor));
//        loQryFeriados.ParamByName('pIdFeriados').AsString := '{7E7DE09C-D070-4320-968E-FCB8011D7FA4}';
        loQryFeriados.ParamByName('pData'      ).AsDate   := ldData;
        loQryFeriados.ParamByName('pDescricao'      ).AsString := 'NOSSA SENHORA APARECIDA';
        loQryFeriados.ExecSQL;

        ldData := StrToDateTime('02/11/'+ IntToStr(liFor));
//        loQryFeriados.ParamByName('pIdFeriados').AsString := '{229CE7D1-3616-465D-B552-12D4839E452B}';
        loQryFeriados.ParamByName('pData'      ).AsDate   := ldData;
        loQryFeriados.ParamByName('pDescricao'      ).AsString := 'FINADOS';
        loQryFeriados.ExecSQL;

        ldData := StrToDateTime('15/11/'+ IntToStr(liFor));
//        loQryFeriados.ParamByName('pIdFeriados').AsString := '{19A5B7F3-6D88-457E-8CB8-E14D729C3847}';
        loQryFeriados.ParamByName('pData'      ).AsDate   := ldData;
        loQryFeriados.ParamByName('pDescricao'      ).AsString := 'PROCLAMAÇÃO DA REPÚBLICA';
        loQryFeriados.ExecSQL;

//        ldData := StrToDateTime('08/12/'+ IntToStr(liFor));
//        loQryFeriados.ParamByName('pIdFeriados').AsString := '{E698516D-56EC-4EA0-B0C5-F826835319C5}';
//        loQryFeriados.ParamByName('pData'      ).AsDate   := ldData;
//        loQryFeriados.ParamByName('pDescricao'      ).AsString := 'NOSSA SENHORA DA CONCEIÇÃO';
//        loQryFeriados.ExecSQL;

        ldData := StrToDateTime('25/12/'+ IntToStr(liFor));
//        loQryFeriados.ParamByName('pIdFeriados').AsString := '{EFA3DE39-A539-4CE3-BB06-8E22CCEDA655}';
        loQryFeriados.ParamByName('pData'      ).AsDate   := ldData;
        loQryFeriados.ParamByName('pDescricao'      ).AsString := 'NATAL';
        loQryFeriados.ExecSQL;
      end;
      TUtil.Commit(TUtil.getConn,liTransacao);
    end;
  finally
    FreeAndNil(loQryFeriados);
  end;
end;




function AcrescMinutos(dData:TDateTime;iMinutos:integer):TDateTime;//Acrescenta N minutos a uma dataHora
//var
  {
  H, Mi, S, N: Word;
  D, M, Y: Word;
  bAcrescentaDia : boolean;
  }
begin
  Result := dData + StrToTime('00:'+StrZero(iMinutos,2,0)+':00');
  {
  decodeDate(dData,Y,M,D);
  decodeTime(dData,H,Mi,S,N);
  Mi := Mi + 15;
  bAcrescentaDia := false;
  if Mi > 60 then begin
    Mi := Mi-60;
    H := H+1;
    if H > 23 then begin
      H := 00;
      bAcrescentaDia := true;
    end;
  end;
  dDtNovaData := EncodeDate(Y,M,D)+EncodeTime(H,Mi,S,N);
  if bAcrescentaDia then begin
    dDtNovaData := dDtNovaData + 1;
  end;
  }
end;

function IncDecAnos(pdData:TDateTime; piAnos:integer):TDateTime;//Incrementa ou decrementa anos a uma data (Se iAnos for positivo incremento, negativa decrementa)
//var
//  wDia, wMes, wAno : Word;
begin
//  decodeDate(pdData,wAno,wMes,wDia);
//  wAno := wAno+piAnos;
//  if (DateStr(pdData,dtsDM) = '2902') and (not IsLeapYear(wAno)) then begin
//    {Se o dia/mês de pdData é 29/02 e o ano depois de incrementado por piAnos
//    não é bissexto, diminui um dia de wDia para ficar 28/02/}
//    Dec(wDia);
//  end;
//  Result := EncodeDate(wAno,wMes,wDia);
  Result := TUtilMath.IncDecAnos(pdData,piAnos);
end;

//Incrementa meses
function IncDecMes(dData:TDateTime;iTempo:Integer):TDateTime;
//var
//  iDia, iMes, iAno, iFor, iUltDia : integer;
//  lsData: String;
begin
//  Result := dData;
//  iDia := Day(dData);
//  iMes := Month(dData);
//  iAno := Year(dData);
//  if iTempo > 0 Then begin
//    for iFor := 1 to iTempo do begin
//      inc(iMes);
//      if iMes = 13 then begin
//         iMes := 1;
//         inc(iAno);
//      end;
//    end;
//  end else begin
//    for iFor := abs(iTempo) downto 1 do begin
//      dec(iMes);
//      if iMes = 0 then begin
//         iMes := 12;
//         dec(iAno);
//      end;
//    end;
//  end;
//  iUltDia := DaysInMonth(iMes,iAno);
//  if iDia > iUltDia then begin
//    iDia := iUltDia;
//  end;
//  try
//    Result := StrToDateTime(StrZero(iDia,2,0)+'/'+StrZero(iMes,2,0)+'/'+StrZero(iAno,4,0));
//  except
//    Result := 0;
//  end;
//
//  lsData := StrZero(iDia,2,0)+'/'+StrZero(iMes,2,0)+'/'+StrZero(iAno,4,0);
//  Result := 0;
//  TryStrToDateTime(lsData,Result);
  Result := TUtilMath.IncDecMes(dData,iTempo);
end;

{Valida as datas de TDateEdit}
function ValidaData(TData: TDateEdit; pbOnExit: Boolean = True): Boolean;overload;
var
  MsgDlg1 : TEvMsgDlg;
  ldData: TDateTime;
begin
  Result := true;
//  try
//    if (Trim(Copy(TData.Text,1,2)+Copy(TData.Text,4,2)+Copy(TData.Text,7,4)) <> '')
//      and ((pbOnExit)
//      or (Length(fSoNumeros(TData.Text)) = 8))
//    then begin
//      ldData := 0;
//      StrToDateTime(TData.Text);
//    end;
//  except
//    Result := false;
//    MsgDlg1 := TEvMsgDlg.Create(nil);
//    try
//      MsgDlg1.MsgError('A data '+TData.Text+' não é válida.');
//      TData.Date := 0;
//    finally
//      FreeAndNil(MsgDlg1);
//    end;
//    if TData.CanFocus then begin
//      TData.SetFocus;
//      TData.SelStart := 0;
//    end;
//    Exit;
//  end;


  if (Trim(Copy(TData.Text,1,2)+Copy(TData.Text,4,2)+Copy(TData.Text,7,4)) <> '')
    and ((pbOnExit)
    or (Length(fSoNumeros(TData.Text)) = 8))
  then begin
    ldData := 0;
    if (not TryStrToDate(TData.Text,ldData)) then begin
      MsgDlg1 := TEvMsgDlg.Create(nil);
      try
        MsgDlg1.MsgError('A data '+TData.Text+' não é válida.');
        TData.Date := 0;
      finally
        FreeAndNil(MsgDlg1);
      end;
      if TData.CanFocus then begin
        TData.SetFocus;
        TData.SelStart := 0;
      end;
    end;
    Exit;
  end;
end;

function ValidaData(TData: TEvMonthYear; pbOnExit: Boolean = True): Boolean;overload;
var
  MsgDlg1 : TEvMsgDlg;
  ldData: TDateTime;
begin
  Result := False;
  if (Trim(Copy(TData.Text,1,2)+Copy(TData.Text,7,4)) <> '')
    and ((pbOnExit)
    or (Length(fSoNumeros(TData.Text)) = 6))
  then begin
    if (Length(fSoNumeros(TData.Text)) = 6) then begin
      ldData := 0;
      if (not TryStrToDate('01/'+TData.Text,ldData)) then begin
        MsgDlg1 := TEvMsgDlg.Create(nil);
        try
          MsgDlg1.MsgError('A data '+TData.Text+' não é válida.');
//          TData.DateValue := TP_DATA_EMPTY;
        finally
          FreeAndNil(MsgDlg1);
        end;
        if TData.CanFocus then begin
          TData.SetFocus;
          TData.SelStart := 0;
        end;
      end else begin
        Result := True;
      end;
      Exit;
    end;
  end;
end;


{Valida as datas de TDateEdit. Deve ser colocado no onExit do componente
TDateEdit}
function ValidaDataExit(TData: TDateEdit): Boolean;
var
  MsgDlg1 : TEvMsgDlg;
  ldData: TDateTime;
begin
  Result := true;
//  try
//    if (Length(fSoNumeros(TData.Text)) = 8)
//      and (Trim(Copy(TData.Text,1,2)+Copy(TData.Text,4,2)+Copy(TData.Text,7,4)) <> '')
//    then begin
//      StrToDateTime(TData.Text);
//    end;
//  except
//    Result := false;
//    MsgDlg1 := TEvMsgDlg.Create(nil);
//    try
//      MsgDlg1.MsgError('A data '+TData.Text+' não é válida.');
//      TData.Date := 0;
//    finally
//      FreeAndNil(MsgDlg1);
//    end;
//    if TData.CanFocus then begin
//      TData.SetFocus;
//      TData.SelStart := 0;
//    end;
//    Exit;
//  end;

  if (Trim(Copy(TData.Text,1,2)+Copy(TData.Text,4,2)+Copy(TData.Text,7,4)) <> '')
    and (Length(fSoNumeros(TData.Text)) = 8)
  then begin
    ldData := 0;
    if (not TryStrToDate(TData.Text,ldData)) then begin
      MsgDlg1 := TEvMsgDlg.Create(nil);
      try
        MsgDlg1.MsgError('A data '+TData.Text+' não é válida.');
        TData.Date := 0;
      finally
        FreeAndNil(MsgDlg1);
      end;
      if TData.CanFocus then begin
        TData.SetFocus;
        TData.SelStart := 0;
      end;
    end;
    Exit;
  end;
end;


function MesAno(dData:TDateTime;bExtenso:boolean):string; //Retorna MM/YYYY ou mês/YYYY
var
  sMesAno, sMesExtenso : string;
begin
  if (dData <> TP_DATA_EMPTY) then begin
    sMesAno := DateStr(dData,dtsMY);
    if not bExtenso then begin
      sMesAno := Copy(sMesAno,1,2)+'/'+Copy(sMesAno,3,4);
    end else begin
      sMesExtenso := FirstUpper(MonthName(dData));
      sMesAno := sMesExtenso+'/'+Copy(sMesAno,3,4);
    end;
    Result := sMesAno;
  end else begin
    Result := '';
  end;
end;

function MyMonthsBetween(dData_i,dData_f:TDateTime;bPropor,bMesCalend:Boolean):Integer; // Verifica a quantidade de meses em um intervalo de datas
//var
//  iMeses, iCont : integer;
//  iDias : Extended;
//  wDia, wMes, wAno : word;
//  dDataTeste, d_Data, d_DataAnt : TDateTime;
begin
//  d_Data := dData_i;
//  d_DataAnt := dData_i;
//  iDias := 0;
//  iCont := 0;
//  iMeses := 0;
//  DecodeDate(dData_i,wAno,wMes,wDia);
//  if bMesCalend then begin
//    d_DataAnt := dData_i;
//    wDia  := 1;
//    wMes  := month(dData_i)+1;
//    if month(dData_i) = 12 then begin
//      wAno := wAno+1;
//      wMes := 1;
//    end;
//    iCont := 1;
////   SET DATE ANSI // data no formato AA/MM/DD
//    if mesAno(dData_f,false) = mesAno(dData_i,false) then begin
//      if (((dData_f - dData_i)+ 1) >= 15) and (bPropor) then begin
//        inc(iMeses);
//      end;
////    end else if mesAno(dData_f,false) > mesAno(dData_i,false) then begin
//    end else if dData_f > dData_i then begin
//      if ((EndOfMonth(dData_i)- dData_i)+1 >= 15) and (bPropor) then begin
//        inc(iMeses);
//      end;
//    end;
//    d_Data := EncodeDate(wAno,wMes,wDia);
//    while EndOfMonth(d_Data) < BeginOfMonth(dData_f) do begin
//      d_DataAnt := d_Data;
//      inc(wMes);
//      if wMes > 12 then begin
//         wMes := 1;
//         inc(wAno);
//      end;
//      if wDia > day(EndOfMonth(EncodeDate(wAno,wMes,1))) then begin
//        wdia := day(EndOfMonth(EncodeDate(wAno,wMes,1)));
//      end;
//      d_Data := EncodeDate(wAno,wMes,wDia);
//      if d_Data <= dData_f then begin
//         inc(iMeses);
//      end;
//    end;
//    if (bPropor) then begin
//      iDias := (dData_f-EndOfMonth(d_DataAnt));
//      if iDias >= 15 then begin
//        inc(iMeses);
//      end;
//    end;
//  end else begin
//    iCont := 1;
//    while d_Data < dData_f do begin
//      d_DataAnt := d_Data;
//      inc(wMes);
//      if wMes > 12 then begin
//         wMes := 1;
//         inc(wAno);
//      end;
//      if wDia > day(EndOfMonth(EncodeDate(wAno,wMes,1))) then begin
//        wdia := day(EndOfMonth(EncodeDate(wAno,wMes,1)));
//      end;
//      d_Data := EncodeDate(wAno,wMes,wDia);
//      if ((d_Data-1) <= dData_f) then begin
//         inc(iMeses);
//      end;
//    end;
//
//    if (bPropor) and ((d_Data-1) > dData_f) then begin
//      iDias := (dData_f - d_DataAnt )+1;
//      if (iDias >= 15) then begin
//        inc(iMeses);
//      end;
//    end;
//  end;
//  Result := iMeses;

  Result := TUtilDate.MyMonthsBetween(dData_i,dData_f,bPropor,bMesCalend);
end;

function MyYearsBetween(dDt1,dDt2:TDateTime):integer;//Retorna a quantidade de anos entre duas datas
var
  bBissexto : boolean;
begin
  {Acrescenta 1 dia a data final, pois, caso contrário, ao incrementar o ano
   dDt1 ficaria maior que dDt2 e, com isso, não incrementaria o resultado
   dessa função.

   Exemplo se não incrementasse 1 dia a data final:
   Data Inicial = 01.01.2010
   Data Final = 31.12.2010
   Data Inicial incrementata em um ano = 01.01.2011
   Como a data inicial, após o incremento de 1 ano ultrapassou a data final,
   essa função não incrementa o resultado da quantidade de anos.

   Exemplo incrementando 1 dia a data final:
   Data Inicial = 01.01.2010
   Data Final = 31.12.2010
   Data Final incrementada em um dia = 01.01.2011
   Data Inicial incrementata em um ano = 01.01.2011
   Como a data inicial, após o incremento de 1 ano é menor igual a data final,
   essa função incrementa o resultado da quantidade de anos. Retornando com isso
   a quantidade de anos entre duas datas corretamente.
   }
  dDt2 := dDt2+1;
  {Se a data for 29 de fevereiro}
  if (day(dDt1) = 29) and (month(dDt1) = 2) then begin
    bBissexto := true;
    dDt1 := dDt1-1; //Diminue um dia para não dar erro na função IncDecAnos
  end else begin
    bBissexto := false;
  end;
  Result := 0;
  while dDt1 <= dDt2 do begin
    {Se dDt1 for 29 de fevereiro, diminue um dia para não dar erro na
    função IncDecAnos}
    if (day(dDt1) = 29) and (month(dDt1) = 2) then begin
      dDt1 := dDt1-1;
    end;
    {Incrementa 1 ano}
    dDt1 := IncDecAnos(dDt1,1);
    {Se a data inicial era 29 de fevereiro e o ano atual de dDt1 é
    bissexto, retorna dDt1 para 29 de fevereiro}
    if (bBissexto) and (IsLeapYear(year(dDt1))) then begin
      dDt1 := EndOfMonth(dDt1);
    end;
    {Compara para ver se ainda é necessário incrementar o contador de anos}
    if dDt1 <= dDt2 then begin
      inc(Result);
    end;
  end;
end;

procedure DifDatas(dData_i,dData_f:TDateTime; var iAnos,iMeses,iDias: Integer); {Diferença entre datas}
var
  dData: TDate;
begin
  iAnos := MyYearsBetween(dData_i,dData_f);
  dData := IncDecAnos(dData_i,iAnos);
  iMeses := MyMonthsBetween(dData,dData_f,false,false);
  dData := IncDecMes(dData,iMeses);
  iDias := Trunc((dData_f-dData)+1);
end;

function NroSemana(Data: TDateTime): shortint; //Retorna o nº da semana dentro do ano
var
  dt1: TDateTime;
  dif: integer;
begin
  dt1:=StrtoDate('01/01/'+
   FormatDateTime('yyyy',Data)); // Primeiro dia do ano
  dt1:=dt1-DayofWeek(dt1); // Último sábado do ano anterior
  dif:=trunc(Data-dt1);
  Result:=((dif-1) div 7)+1;
end;

function DataParaStoreProcedure(Data: TDate): String; //Retorna uma data no formato '01.01.1980' para ser inserida em um parâmetro de uma Store Procedure, em uma sentença SQL de uma query
begin
  result := quotedStr(StrZero(Day(Data),2,0)+'.'+StrZero(Month(Data),2,0)+'.'+StrZero(year(Data),4,0));
end;

function InterDatas(dDt1,dDt2,dDt3,dDt4:TDate):integer;//Retorna a quantidade de dias de intersseção entre o período dDt1,dDt2 e o período dDt3 e dDt4
var
  dDataInicial, dDataFinal:TDate;
begin
  Result := 0;
  if (dDt1 <= dDt2) and (dDt3 <= dDt4) and ((dDt1 <= dDt4) and (dDt2 >= dDt3)) then begin
    if (dDt1 > dDt3) then begin
      dDataInicial := dDt1;
    end else begin
      dDataInicial := dDt3;
    end;
    if (dDt2 < dDt4) then begin
      dDataFinal := dDt2;
    end else begin
      dDataFinal := dDt4;
    end;
  end;
end;

function DateInBetween(ldData,ldData1,ldData2: TDate): Boolean; //Verifica se ldData está entre ldData1 e ldData2
begin
  Result := false;
  if ldData1 < ldData2 then begin
    if (ldData >= ldData1) and (ldData <= ldData2) then begin
      Result := true;
    end;
  end else begin
    if (ldData >= ldData2) and (ldData <= ldData1) then begin
      Result := true;
    end;
  end;
end;

function DiaUtilAnterior(pConn: TFDConnection; pdData: TDate; pbSabadoUtil: Boolean = True): TDate;
var
  loQryFeriados: TFDQuery;
  lbFeriado: Boolean;
begin
  loQryFeriados := TFDQuery.Create(nil);
  try
    loQryFeriados.Connection := pConn;
    loQryFeriados.SQL.Add('SELECT DATA FROM FERIADOS');
    loQryFeriados.Open;
    if (not pbSabadoUtil) and (DayOfWeek(pdData) = 7) then begin
      pdData := pdData - 1;
    end else if DayOfWeek(pdData) = 1 then begin
      pdData := pdData - 2;
    end;
    lbFeriado := true;
    while lbFeriado do begin
      if not loQryFeriados.Locate('DATA',pdData,[]) then begin
        lbFeriado := false;
      end else begin
        pdData := pdData-1;
      end;
    end;
    Result := pdData;
  finally
    FreeAndNil(loQryFeriados);
  end;
end;

function DiaUtilPosterior(pConn: TFDConnection; pdData: TDate; pbSabadoUtil: Boolean = True): TDate;
var
  loQryFeriados: TFDQuery;
  lbFeriado: Boolean;
begin
  loQryFeriados := TFDQuery.Create(nil);
  try
    loQryFeriados.Connection := pConn;
    loQryFeriados.SQL.Add('SELECT DATA FROM FERIADOS');
    loQryFeriados.Open;
    lbFeriado := true;
    while lbFeriado do begin
      if not loQryFeriados.Locate('DATA',pdData,[]) then begin
        lbFeriado := false;
      end else begin
        pdData := pdData+1;
      end;
    end;
    if (not pbSabadoUtil) and (DayOfWeek(pdData) = 7) then begin
      pdData := pdData + 2;
    end else if DayOfWeek(pdData) = 1 then begin
      pdData := pdData + 1;
    end;
    Result := pdData;
  finally
    FreeAndNil(loQryFeriados);
  end;
end;

function DataExtenso(pData: TDate): String;
begin
  Result := StrZero(Day(pData),2,0)+' de '+MonthName(pData)+' de '+StrZero(Year(pData),4,0);
end;

function StrSemBarrasToDate(psData: String): TDate; {Recebe uma data no formato 03052011 e retorna 03/05/2011}
var
 ldData: TDateTime;
begin
//  Result := StrToDate(Copy(psData,1,2)+'/'+Copy(psData,3,2)+'/'+Copy(psData,5,4));
  ldData := 0;
  TryStrToDate(Copy(psData,1,2)+'/'+Copy(psData,3,2)+'/'+Copy(psData,5,4),ldData);
  Result := ldData;
end;


function DiasUteis(pdDataI,pdDataF: TDateTime; poConn: TFDConnection;
  pbSabadoUtil: boolean): Integer;
var
 liFeriados: Integer;
begin
  Result := 0;

  while (pdDataI <= pdDataF) do begin
    if ((not pbSabadoUtil) and (DayOfWeek(pdDataI) <> 1) and (DayOfWeek(pdDataI) <> 7)) then begin
      Inc(Result);
    end else if ((pbSabadoUtil) and (DayOfWeek(pdDataI) <> 7)) then begin
      Inc(Result);
    end;
    pdDataI := pdDataI+1;
  end;
  Result := Result-QtdeferiadosPeriodo(pdDataI,pdDataF,poConn,pbSabadoUtil);
  if Result < 0 then begin
    Result := 0;
  end;
end;

function QtdeferiadosPeriodo(pdDataI,pdDataF: TDateTime; poConn: TFDConnection;
  pbSabadoUtil: boolean): Integer;
var
  loQryFeriados: TFDQuery;
begin
  Result := 0;
  loQryFeriados := TFDQuery.Create(nil);
  try
    loQryFeriados.Connection := poConn;
    {Seleciona os fériados no intervalo de datas, exceto os fériados aos
     domingos}
    loQryFeriados.SQL.Add('SELECT count(F.ID_FERIADOS) AS QTDE FROM FERIADOS F WHERE (F.DATA BETWEEN :pDataInicial AND :pDataFinal) AND (EXTRACT(WEEKDAY FROM F.DATA) <> 0)');
    if not pbSabadoUtil then begin
      {Se o sábado não é útil, não computa os fériados no sábado.}
      loQryFeriados.SQL.Add(' AND (EXTRACT(WEEKDAY FROM F.DATA) <> 6)');
    end;
    loQryFeriados.ParamByName('pDataInicial').AsDate := pdDataI;
    loQryFeriados.ParamByName('pDataFinal'  ).AsDate := pdDataF;
    loQryFeriados.Open;
    Result := loQryFeriados.FieldByName('QTDE').AsInteger;
  finally
    FreeAndNil(loQryFeriados);
  end;
end;

//Arrays
function aSortS(sElemento:String;aArray:Array of string):Integer;overload;//Localiza um elemento dentro de um array string
var
  iFor : integer;
begin
  result := -1;
  for iFor := low(aArray) to high(aArray) do begin
    if sElemento = aArray[iFor] then begin
      result := iFor;
      break;
    end;
  end;
end;

function aSortS(sElemento:String;oStrings: TStrings):Integer; overload;//Localiza um elemento dentro de um TStrings
var
  iFor : integer;
begin
  result := -1;
//  for iFor := low(oStrings) to high(oStrings) do begin
  for iFor := 0 to oStrings.Count-1 do begin
    if sElemento = oStrings[iFor] then begin
      result := iFor;
      break;
    end;
  end;
end;

function aSortS(sElemento:String;oStrings: TStringList):Integer; overload;//Localiza um elemento dentro de um TStringList
var
  iFor : integer;
begin
  result := -1;
  for iFor := 0 to oStrings.Count-1 do begin
    if sElemento = oStrings.Strings[iFor] then begin
      result := iFor;
      break;
    end;
  end;
end;


function aSortI(iElemento:integer;aArray:Array of integer):Integer;//Localiza um elemento dentro de um array Integer
var
  iFor : integer;
begin
  result := -1;
  for iFor := low(aArray) to high(aArray) do begin
    if iElemento = aArray[iFor] then begin
      result := iFor;
      break;
    end;
  end;
end;

function aSortD(dElemento:TDateTime;aArray:Array of TDateTime):Integer;//Localiza um elemento dentro de um array DateTime
var
  iFor : integer;
begin
  result := -1;
  for iFor := low(aArray) to high(aArray) do begin
    if dElemento = aArray[iFor] then begin
      result := iFor;
      break;
    end;
  end;
end;

//Strings
function Stuff(sString,sInsere:string;iInicio,iElimina:integer):String;// Esta função modifica uma string (igual ao clipper)
var
  sNovaString, sPrimParte, sSegParte : string;
begin
  if iInicio = 1 then begin
    sPrimParte := '';
  end else if iInicio >= 2 then begin
    sPrimParte := Copy(sString,1,iInicio-1);
  end;
  sSegParte  := Copy(sString,iInicio,Length(sString)-Length(sPrimParte));
  if iElimina > 0 then begin
    sSegParte := Copy(sSegParte,iElimina+1,Length(sSegParte)-iElimina);
  end;
  if Length( sInsere ) > 0 then begin
    sNovaString := sPrimParte + sInsere + sSegParte;
  end else begin
    sNovaString := sPrimParte + sSegParte;
  end;
  Stuff := Trim(sNovaString);
end;

function Valid_Caracter(psString: String; pbEliminaBranco: Boolean = False): String;//Substitue os caracteres não válidos para criação de arquivo.
//var
//   sAcentos1, sAcentos2 : String;
//   iFor, iAux : Integer;
begin
//  sAcentos1 := 'ÁÍÓÚÉ ÄÏÖÜË ÀÌÒÙÈ ÃÕ ÂÎÔÛÊÑ áíóúé äïöüë àìòùè ãõ âîôûêñ Ççªº!@#$%^&*()_+-=[]\{}|:";<>?,./';
//  sAcentos2 := 'AIOUE AIOUE AIOUE AO AIOUEN aioue aioue aioue ao aiouen Ccao                              ';
//  for iFor := 1 to Length(psString) do begin
//    iAux := Pos(psString[iFor], sAcentos1);
//    if (iAux > 0) then begin
//      psString[iFor] := sAcentos2[iAux];
//    end;
//  end;
//  Result := psString;
//  if pbEliminaBranco then begin
//    Result := SubstText(psString,' ','');
//  end;
//  {Retira os caracteres de controle}
//  Result := TRegEx.Replace(Result, '[[:cntrl:]]',''); {utilização da classe POSIX [[:cntrl:]]}
  {Valid_Caracter foi mantita por questão de compatibilidade. Assim que possível,
  Trocar para TUtilFormat.ValidCaracter}
  Result := TUtilFormat.ValidCaracter(psString,pbEliminaBranco);
end;

function fSoNumeros(psString: string): string;
begin
//  {$IFDEF VER230}
   {TRegEx precisa da declaração em uses de
    System.RegularExpressions}
    Result := TRegEx.Replace(psString, '\D','');
//  {$ENDIF}
end;

//function fSoNumeros(sString:string):string;//Retorna uma string sem máscaras
//var
//  iFor : integer;
//  sNovaString, sNumeros : string;
//begin
//  sNumeros := '0123456789';
//  sNovaString := '';
//  for iFor := 1 to Length(sString) do begin
//    if Pos(sString[iFor],sNumeros) > 0 then begin
//      sNovaString := sNovaString + sString[iFor];
//    end;
//  end;
//  Result := sNovaString;
//end;

function InscMfCMasc(psInscMf,psTipo:string):string;//Retorna a InscMf com máscara
begin
//  psInscMf := fSoNumeros(psInscMf);
//  if Trim(psTipo) = 'CNPJ' then begin
//    psInscMf := StrZero(StrToInt64(psInscMf),TAMANHO_CNPJ_SEM_MASCARA,0);
//    psInscMf := Copy(psInscMf,1,2) + '.' + Copy(psInscMf,3,3) + '.' + Copy(psInscMf,6,3) + '/' + Copy(psInscMf,9,4) + '-' + Copy(psInscMf,13,2);
//  end else if Trim(psTipo) = 'CPF' then begin
//    psInscMf := StrZero(StrToInt64(psInscMf),TAMANHO_CPF_SEM_MASCARA,0);
//    psInscMf := Copy(psInscMf,1,3) + '.' + Copy(psInscMf,4,3) + '.' + Copy(psInscMf,7,3) + '-' + Copy(psInscMf,10,2);
//  end else if Trim(psTipo) = 'CEI' then begin
//    psInscMf := StrZero(StrToInt64(psInscMf),TAMANHO_CEI_SEM_MASCARA,0);
//    psInscMf := Copy(psInscMf,1,2) + '.' + Copy(psInscMf,3,3) + '.' + Copy(psInscMf,6,2) + '.' + Copy(psInscMf,8,3) + '/' + Copy(psInscMf,11,2);
//  end;
//  Result := psInscMf;

  Result := TUtilFormat.InscMfCMasc(psInscMf,psTipo);
end;


function SubstText(sTexto, s1, s2: string): string;
begin
  result := '';
  while Pos(s1,sTexto) > 0 do begin
    result := result + Copy(sTexto,1,Pos(s1,sTexto)-1) + s2;
    Delete(sTexto,1,Pos(s1,sTexto)+Length(s1)-1);
  end;
  result := result + sTexto;
end;

function AbreviaNome(sNome: String): String;
var
 sNomes : array[1..20] of string;
 iPos, iFor, iTotalNomes : Integer;
begin
  {Insere um espaço para garantir que todas as letras sejam testadas}
  sNome := Trim(sNome);
  Result := sNome;
  {Pega a posição do primeiro espaço}
  sNome := sNome + #32;
  iPos := Pos(#32, sNome);
  if iPos > 0 then begin
    iTotalNomes := 0;
    {Separa todos os nomes}
    while iPos > 0 do begin
      Inc(iTotalNomes);
      sNomes[iTotalNomes] := Copy(sNome, 1, iPos - 1);
      Delete(sNome, 1, iPos);
      iPos := Pos(#32, sNome);
    end;
    if iTotalNomes > 2 then begin
      {Abreviar a partir do segundo nome, exceto o último.}
      for iFor := 2 to iTotalNomes - 1 do begin
        {Contém mais de 3 letras? (ignorar de, da, das, do, dos, etc.)}
        if Length(sNomes[iFor]) > 3 then begin
          {Pega apenas a primeira letra do nome e coloca um ponto após.}
          sNomes[iFor] := sNomes[iFor][1] + '.';
        end;
      end;
      Result := '';
      for iFor := 1 to iTotalNomes do begin
        Result := Result + Trim(sNomes[iFor]) + #32;
      end;
      Result := Trim(Result);
    end;
  end;
end;

function MyCurrToStr(pdblValor: Currency; piTamanho,piDecimais: Integer;
  pbSeparadores: Boolean; pbZerosEsquerda: Boolean = true): String;
var
  liPos,liParteInteira,liParteDecimal,liFor,liTamanho: Integer;
  lsValor,lsParteInteira,lsParteDecimal,lsDecimalSeparador: string;
begin
  Result := '';
  lsParteInteira := '';
  lsParteDecimal := '';

  if pbSeparadores then begin
    lsDecimalSeparador := FormatSettings.DecimalSeparator;
    liTamanho := piTamanho;
  end else begin
    lsDecimalSeparador := '';
    liTamanho := piTamanho+1;
  end;

  lsValor := strzero(pdblValor,liTamanho,piDecimais);
  lsValor := StrSubst(lsValor,'.',',',0);
  liPos   := Pos(',',lsValor);

  if liPos <> 0 then begin
    lsParteInteira := copy(lsValor,1,liPos-1);
    if piDecimais > 0 then begin
      lsParteDecimal := Copy(lsValor,liPos+1,piDecimais);
      while Length(lsParteDecimal) < piDecimais do begin
        lsParteDecimal := lsParteDecimal+'0';
      end;
    end;
  end else begin
    lsParteInteira := lsValor;
    if piDecimais > 0 then begin
      while Length(lsParteDecimal) < piDecimais do begin
        lsParteDecimal := lsParteDecimal+'0';
      end;
    end;
  end;

  Result := lsParteInteira+lsDecimalSeparador+lsParteDecimal;

  if (not pbZerosEsquerda) then begin
    {Retira os zeros a esquerda}
    while (Copy(Result,1,1) = '0') do begin
      Result := StrSubst(Result,'0','',1);
    end;
  end;

(*
  {Atribui a liParteInteira, a parte inteira de pdblValor}
  lsValor := Trim(FloatToStr(pdblValor));
  lsValor := StrSubst(lsValor,'.',',',0);
  liPos := Pos(',',lsValor);
  liParteInteira := StrToInt(Copy(lsValor,1,liPos-1));
  {Atribui a liParteDecimal, a fração de pdblValor}
  liParteDecimal := StrToInt(Copy(lsValor,liPos+1,2));
  lsParteInteira := '';
  lsParteDecimal := '';

//  {Atribui a liParteInteira, a parte inteira de pdblValor}
//  liParteInteira := trunc(pdblValor);
//  {Atribui a liParteDecimal, a fração de pdblValor}
//  liParteDecimal := StrToInt(FloatToStr(Trunc(frac(pdblValor)*power(10,piDecimais))));

  if piTamanho > 0 then begin
    if (pbSeparadores) then begin
      {Se for definido um tamanho para a string de retorno com separador de
       decimais, então, atribui a Result o StrZero da parte inteira com o
       tamanho definido em piTamnho menos a qtde de decimais acrescido de 1, que
       é do separador.}
      lsParteInteira := StrZero(liParteInteira,piTamanho-(piDecimais+1),0);
    end else begin
      {Se for definido um tamanho para a string de retorno com separador de
       decimais, então, atribui a Result o StrZero da parte inteira com o
       tamanho definido em piTamnho menos a qtde de decimais.}
      lsParteInteira := StrZero(liParteInteira,piTamanho-(piDecimais),0);
    end;
  end else begin
    {Se não foi definido tamanho para a string de retorno, então, atribui a
     Result o Str de liParteInteira}
    lsParteInteira := IntToStr(liParteInteira);
  end;
  if (pbSeparadores) and (piDecimais > 0) then begin
    {Se foi definida a string de retorno com separadores de decimais e, a qtde
     de decimais foi definida como maior que zero, então, acrescenta a string de
     retorno o caracter decimal definido na variável de ambiente
     DecimalSeparator.}
    lsParteInteira := lsParteInteira+DecimalSeparator;
  end;
  if piDecimais > 0 then begin
    {Se foi definida a qtde de decimais maior que zero, então, acrescenta a
     string de retorno a string da quantidade de decimais.}
//    Result+StrZero(liParteDecimal,piDecimais,0);
    lsParteDecimal := IntToStr(liParteDecimal);
    if Length(lsParteDecimal) < piDecimais then begin
      lsParteDecimal := lsParteDecimal+StrZero(0,liParteDecimal-Length(lsParteDecimal),0);
    end;
  end;
  Result := lsParteInteira + lsParteDecimal;
  *)
end;

{Retorna o controle do CNPJ. Ex: 14.008.828/0003-84,
 Retorna 0003}
function ControleCnpj(psCnpj: String): String;
begin
  Result := copy(psCnpj,12,4);
end;

function CentraLinha(piColunaInicial,piTamLinha: Integer; psTexto: String): String; {Retorna a linha com tantos espaços em branco necessários para centralizar o texto na linha}
var
  liColuna: Integer;
begin
  liColuna := Trunc((piTamLinha-(piColunaInicial+Length(psTexto)))/2);
  psTexto  := StrSpace(liColuna-1)+trim(psTexto);
end;

//procedure StringListSort(var poStringList: TStringList);
//var
//  liFor,liFor1: Longword;
//  lsItem: String;
//begin
//  for liFor := 0 to poStringList.Count-1 do begin
//    for liFor1 := liFor+1 to poStringList.Count-1 do begin
//      if StrToInt(fSoNumeros(poStringList.Strings[liFor])) > StrToInt(FSoNumeros(poStringList.Strings[liFor1])) then begin
//        lsItem := poStringList.Strings[liFor];
//        poStringList.Strings[liFor]  := poStringList.Strings[liFor1];
//        poStringList.Strings[liFor1] := lsItem;
//      end;
//    end;
//  end;
//end;

function AddStringList(var poStringList: TStringList; psTexto: string; pbLinhaBranco: Boolean): Integer; {pbLinhaBranco, quando true, adiciona uma linha em branco a stringlist}
begin
  Result := -1;
  if poStringList.IndexOf(psTexto) < 0 then begin
    Result := poStringList.Add(psTexto);
    if pbLinhaBranco then begin
      poStringList.Add(' ');
    end;
  end;
end;

function UpperNome(psNome: String): String;
var
	liFor: Integer;
	lista: Array[0..4] of String[03];

  function NaoAchaPreposicao(Palavra : String): Boolean;
  var
 	  liFor: Integer;
  begin
	  Result := True;
	  for liFor := 0 to 4 do begin
		  if Trim(Palavra) = lista[liFor] then begin
			  Result := False;
		  end;
	  end;
  end;
begin
  psNome := AnsiLowerCase(psNome);
	Result := psNome;
	lista[0] := 'das';
  lista[1] := 'dos' ;
	lista[2] := 'de';
  lista[3] := 'do' ;
	lista[4] := 'da';
	Result := UpCase(Result[1]) + Copy(Result, 2, Length(Result));
	for liFor := 2 to Length(psNome) do begin
		if (psNome[liFor] = #32) then begin
			if (Copy(psNome,liFor+1,1) <> 'e') then begin
				if (NaoAchaPreposicao(Copy(psNome,liFor+1,3))) then begin
					Result := Copy(Result, 1, liFor) + UpCase(Result[liFor+1]) + Copy(Result, liFor+2, Length(Result));
				end;
			end;
		end;
	end;
end;

//Leia mais em: Function para validar Email http://www.devmedia.com.br/function-para-validar-email/16012#ixzz28vLPCbml
//function ValidarEMail(psEnderecoEmail: string): Boolean;
//begin
// psEnderecoEmail := Trim(UpperCase(psEnderecoEmail));
//
// if Pos('@', psEnderecoEmail) > 1 then begin
//   Delete(psEnderecoEmail, 1, pos('@', psEnderecoEmail));
//   Result := (Length(psEnderecoEmail) > 0) and (Pos('.', psEnderecoEmail) > 2);
// end else begin
//   Result := False;
// end;
//end;

function ValidarEMail(const psEnderecoEmail: String): Boolean;
const
  CaraEsp: array[1..40] of string[1] =
  ( '!','#','$','%','¨','&','*',
  '(',')','+','=','§','¬','¢','¹','²',
  '³','£','´','`','ç','Ç',',',';',':',
  '<','>','~','^','?','/','','|','[',']','{','}',
  'º','ª','°');
var
  liFor,liCont   : integer;
  lsEnderecoEmail    : ShortString;
begin
  lsEnderecoEmail := psEnderecoEmail;
  Result := True;
  liCont := 0;
  if lsEnderecoEmail <> '' then begin
    if (Pos('@', lsEnderecoEmail)<>0) and (Pos('.', lsEnderecoEmail)<>0) then begin  {existe @ .}
      if (Pos('@', lsEnderecoEmail)=1)
        or (Pos('@', lsEnderecoEmail)= Length(lsEnderecoEmail))
        or (Pos('.', lsEnderecoEmail)=1)
        or (Pos('.', lsEnderecoEmail)= Length(lsEnderecoEmail))
        or (Pos(' ', lsEnderecoEmail)<>0)
      then begin
        Result := False
      end else begin  {@ seguido de . e vice-versa}
        if (abs(Pos('@', lsEnderecoEmail) - Pos('.', lsEnderecoEmail)) = 1) then begin
          Result := False
        end else begin
          for liFor := 1 to 40 do begin {se existe Caracter Especial}
            if Pos(CaraEsp[liFor], lsEnderecoEmail)<>0 then begin
              Result := False;
            end;
          end;
          for liFor := 1 to length(lsEnderecoEmail) do begin {se existe apenas 1 @}
            if lsEnderecoEmail[liFor] = '@' then begin
              liCont := liCont + 1; {. seguidos de .}
            end;
            if (lsEnderecoEmail[liFor] = '.') and (lsEnderecoEmail[liFor+1] = '.') then begin
              Result := false;
            end;
          end;
          {. no f, 2ou+ @, . no i, - no i, _ no i}
          if (liCont >=2)
            or ( lsEnderecoEmail[length(lsEnderecoEmail)]= '.' )
            or ( lsEnderecoEmail[1]= '.' ) or ( lsEnderecoEmail[1]= '_' )
            or ( lsEnderecoEmail[1]= '-' )
          then begin
            Result := false;
          end;
          {@ seguido de COM e vice-versa}
          if (abs(Pos('@', lsEnderecoEmail) - Pos('com', lsEnderecoEmail)) = 1) then begin
            Result := False;
          end;
          {@ seguido de - e vice-versa}
          if (abs(Pos('@', lsEnderecoEmail) - Pos('-', lsEnderecoEmail)) = 1) then begin
            Result := False;
          end;
          {@ seguido de _ e vice-versa}
          if (abs(Pos('@', lsEnderecoEmail) - Pos('_', lsEnderecoEmail)) = 1) then begin
            Result := False;
          end;
        end;
      end;
    end else begin
      Result := False;
    end;
  end;
end;


//Tirar essa função de LibMega, ver onde é mais apropriado colocar.
//Altera a data e hora de um arquivo
//Function DefineDataHoraArq(NomeArq: string; DataHora: TDateTime): boolean;
//function SetFileDateTime(NomeArq: string; DataHora: TDateTime): boolean;
//var
//  F: integer;
//begin
//  Result := false;
//  F := FileOpen(NomeArq, fmOpenWrite or fmShareDenyNone);
//  try
//    if F > 0 then begin
//      Result := FileSetDate(F, DateTimeToFileDate(DataHora)) = 0;
//    end;
//  finally
//    FileClose(F);
//  end;
//end;
(*
function SetFileDateTime(FileName: String; NewDateTime: TDateTime): Boolean;
var
  FileHandle: Integer;
  FileTime: TFileTime;
  LFT: TFileTime;
  LST: TSystemTime;
begin
  Result := False;
  try
    DecodeDate(NewDateTime, LST.wYear, LST.wMonth, LST.wDay);
    DecodeTime(NewDateTime, LST.wHour, LST.wMinute, LST.wSecond,LST.wMilliSeconds);
    if SystemTimeToFileTime(LST, LFT) then
    begin
      if LocalFileTimeToFileTime(LFT, FileTime) then
      begin
        FileHandle := FileOpen(FileName, fmOpenReadWrite or fmShareExclusive);
        if SetFileTime(FileHandle, nil, nil, @FileTime) then
          Result := True;
      end;
    end;
  finally
    FileClose(FileHandle);
  end;
end;
*)

function LockPessimistic(DataSet:TDataSet;sPath:string;IBDataBase:TIBDataBase;IBTransaction:TIBTransaction;sTabela:string):boolean;
var
  QryIndices : TIBQuery;
  IBSQL: TIBSQL;
  sCampo, sComandoSQL : string;
  MsgDlg1 : TEvMsgDlg;
  iTabela, iFor  : integer;
begin
  Result := false;
  if sTabela = '' then begin
    sTabela := GetTableNameFromSQL(TIBQuery(DataSet).Text);
  end;
  //Verifica o nome da tabela
  //  Para utilizar GetTableNameFromSQL precisa da unit DBCommon
//  if pos('FROM CADASTRO',TIBQuery(DataSet).Text) > 0 then begin
//    sTabela := 'CADASTRO';
//  end else begin
//    sTabela := GetTableNameFromSQL(TIBQuery(DataSet).Text);
//  end;

//  sCampo := TIBQuery(DataSet).FieldDefs[TIBQuery(DataSet).FieldCount-1].Name;
  {sCampo pega o segundo campo pq o primeiro é o ID}
  sCampo := TIBQuery(DataSet).FieldDefs[1].Name;
//  sComandoSQL := 'UPDATE ' + sTabela + ' SET '+sCampo+' = '+sCampo+' WHERE ' + TIBQuery(DataSet).FieldDefs[0].Name + ' = :p' + TIBQuery(DataSet).FieldDefs[0].Name;
//  if sTabela = 'CLANCAMENTOS' then begin
//    sComandoSQL := 'UPDATE ' + sTabela + ' SET '+sCampo+' = '+sCampo+', DATA = '+QuotedStr('31/12/2003')+' WHERE ID = :pID';
//  end else begin
    sComandoSQL := 'UPDATE ' + sTabela + ' SET '+sCampo+' = '+sCampo+' WHERE ID = :pID';
//  end;

  //Este recupera o índice primario (se existir somente indice primario}
//  QryIndices.SQL.Add('SELECT A.RDB$FIELD_NAME FROM RDB$INDEX_SEGMENTS A WHERE A.RDB$INDEX_NAME = (SELECT RDB$INDEX_NAME FROM RDB$INDICES WHERE RDB$RELATION_NAME = :pTabela)');

  //Este recupera o índice primario (mesmo se já existir indice secundario}
  {
  QryIndices := TIBQuery.Create(nil);
  QryIndices.DataBase := IBDataBase;
  QryIndices.SQL.Add('Select Distinct A.RDB$FIELD_NAME as CAMPO, B.RDB$TYPE_NAME as TIPO From RDB$RELATION_FIELDS A,');
  QryIndices.SQL.Add('RDB$TYPES B, RDB$FIELDS C Where A.RDB$FIELD_SOURCE  = C.RDB$FIELD_NAME and C.RDB$FIELD_TYPE =');
  QryIndices.SQL.Add('B.RDB$TYPE and B.RDB$FIELD_NAME = '+QuotedStr('RDB$FIELD_TYPE')+' and A.RDB$RELATION_NAME = :pTabela');
  QryIndices.SQL.Add(' and A.RDB$FIELD_NAME in (select distinct B.RDB$FIELD_NAME from RDB$INDICES A, RDB$INDEX_SEGMENTS');
  QryIndices.SQL.Add(' B, RDB$RELATION_CONSTRAINTS C where A.RDB$INDEX_NAME = B.RDB$INDEX_NAME and B.RDB$INDEX_NAME = ');
  QryIndices.SQL.Add(' C.RDB$INDEX_NAME and C.RDB$CONSTRAINT_TYPE = '+QuotedStr('PRIMARY KEY')+' and A.RDB$RELATION_NAME = :pTabela)');
  QryIndices.SQL.Add(' order by RDB$FIELD_POSITION');
  QryIndices.ParamByName('pTabela').AsString := sTabela;
  QryIndices.Prepare;
  QryIndices.Open;
  QryIndices.First;
  while not QryIndices.Eof do begin
    sComandoSQL := sComandoSQL + ' AND ' + Trim(QryIndices.FieldByName('CAMPO').AsString) + ' = :p' + Trim(QryIndices.FieldByName('CAMPO').AsString);
    QryIndices.Next;
  end;
  }
  IBSQL := TIBSQL.Create(Application);
  try
    with IBSQL do begin
      Database := IBDataBase;
      SQL.Clear;
      SQL.Text := sComandoSQL;
//      try
        ParamByName('pID').AsInteger := DataSet.FieldByName('ID').AsInteger;
//      except
//        MsgDlg1 := TEvMsgDlg.Create(nil);
//        MsgDlg1.MessageType := mtWarning;
//        MsgDlg1.Style := msCenter;
//        MsgDlg1.LineSeparator := '|';
//        MsgDlg1.Text := 'Faça download do programa AT-Atualizador de Tabelas|em http://www.megasoftware.com.br|instale e execute para compatibilizar as|tabelas com esta nova versão.';
//        MsgDlg1.Buttons := [mbOk];
//        MsgDlg1.Execute;
//        MsgDlg1.Free;
//      end;
      try
//        QryIndices.First;
//        while not QryIndices.Eof do begin
//          IBSQL.ParamByName('p'+Trim(QryIndices.FieldByName('CAMPO').AsString)).Value := DataSet.FieldByName(Trim(QryIndices.FieldByName('CAMPO').AsString)).Value;
//          QryIndices.Next;
//        end;
        ExecQuery;
        Result := true;
      except on E: EIBInterBaseError do
        begin
          DataSet.Cancel;
        end;
      end;
    end;
  finally
    IBSQL.Close;
    IBSQL.Free;
  end;
end;

//procedure CapsOnOff(State: Boolean);
procedure CapsLock(State: Boolean);
begin
  if (State and ((GetKeyState(VK_CAPITAL) and 1) = 0)) or
     ((not State) and ((GetKeyState(VK_CAPITAL) and 1) = 1)) then begin
    KeyBd_Event(VK_CAPITAL, $45, KEYEVENTF_EXTENDEDKEY or 0, 0);
    KeyBd_Event(VK_CAPITAL, $45, KEYEVENTF_EXTENDEDKEY or KEYEVENTF_KEYUP, 0);
  end;
end;

procedure NumLock(State: Boolean);
begin
  if (State and ((GetKeyState(VK_NUMLOCK) and 1) = 0)) or
     ((not State) and ((GetKeyState(VK_NUMLOCK) and 1) = 1)) then begin
    KeyBd_Event(VK_NUMLOCK, $45, KEYEVENTF_EXTENDEDKEY or 0, 0);
    KeyBd_Event(VK_NUMLOCK, $45, KEYEVENTF_EXTENDEDKEY or KEYEVENTF_KEYUP, 0);
  end;
end;

function fGravaRegistro(ClienteDataSet :TClientDataSet;sTipo:String;bMsg:boolean=true):boolean;
begin
  Result := false;
  if UpperCase(sTipo) = 'POST' then begin
    ClienteDataSet.Post;
  end else begin
    ClienteDataSet.Delete;
  end;
  if ClienteDataSet.ApplyUpdates(0) <> 0 then begin
    ClienteDataSet.Cancel;
    ClienteDataSet.CancelUpdates;
    if bMsg then begin //Se deve mostrar mensagen
      if UpperCase(sTipo) = 'POST' then begin
        showmessage('Problema na gravação. Registro não gravado');
      end else begin
        showmessage('Problema na exclusão. Registro não excluído');
      end;
    end;
    Result := false;
  end else begin
    ClienteDataSet.Close;
    ClienteDataSet.Open;
    if bMsg then begin //Se deve mostrar mensagen
      if UpperCase(sTipo) = 'POST' then begin
        showmessage('Registro gravado.');
      end else begin
        showmessage('Registro excluído.');
      end;
    end;
    Result := true;
  end;
  {
  if ClienteDataSet.ApplyUpdates(0) <> 0 then begin
    ClienteDataSet.Cancel;
    ClienteDataSet.CancelUpdates;
    if UpperCase(sTipo) = 'POST' then begin
      showmessage('Problema na gravação. Registro não gravado');
    end else begin
      showmessage('Problema na exclusão. Registro não excluído');
    end;
    Result := false;
  end else begin
    ClienteDataSet.Close;
    ClienteDataSet.Open;
    if bMsg then begin //Se deve mostrar mensagen
      if UpperCase(sTipo) = 'POST' then begin
        showmessage('Registro gravado.');
      end else begin
        showmessage('Registro excluído.');
      end;
    end;
    Result := true;
  end;
  }
end;

//function VerImpressoraONLINE: Cardinal;
//var
//  hPrinter  : THandle;
//  pInfo:  PPrinterInfo2;
//  bytesNeeded: DWORD;
//begin
//  hprinter := GetCurrentPrinterHandle;
//  try
//    Winspool.GetPrinter( hPrinter, 2, Nil, 0, @bytesNeeded );
//    pInfo := AllocMem( bytesNeeded );
//    try
//      Winspool.GetPrinter( hPrinter, 2, pInfo, bytesNeeded, @bytesNeeded );
//       Result := pInfo^.Status;
//    finally
//      FreeMem( pInfo );
//    end;
//  finally
//    ClosePrinter( hPrinter );
//  end;
//end;

Procedure fCriaFormModal(FormClasse :TComponentClass; NomeForm :TForm );
begin
  Application.CreateForm(FormClasse,NomeForm);
  try
    NomeForm.ShowModal;
  finally
//    NomeForm.Release;
//    NomeForm := nil;
    FreeAndNil(NomeForm);
  end;
end;

{*-----------------------------------------------------------------------------
  Função que faz os componentes descendentes do TWinControl terem seus cantos
  arredondados.
    Exemplo:
      // TMemo:
      Memo1.BorderStyle := bsNone;
      MakeRounded(Memo1);
      // TEdit:
      Edit2.BorderStyle := bsNone;
      MakeRounded(Edit2);
      // TPanel:
      MakeRounded(Panel1);
      // TStaticText:
      MakeRounded(StaticText1);
      // TForm
      Form1.BorderStyle := bsNone;
      MakeRounded(Form1);
  Dica retirada do site: <http://delphitodelphi.blogspot.com/2008/03/dica-painel
  -com-cantos-arredondados.html>
  @Autor: Rubem Nascimento
  @Adicionada por: Ivan Neves
  @Data:  25/03/2009
------------------------------------------------------------------------------*}
procedure MakeRounded(Control: TWinControl);
var
  R: TRect;
  Rgn: HRGN;
begin
  with Control do begin
   R := ClientRect;
   rgn := CreateRoundRectRgn(R.Left, R.Top, R.Right, R.Bottom, 20, 20);
   Perform(EM_GETRECT, 0, lParam(@r));
   InflateRect(r, - 5, - 5);
   Perform(EM_SETRECTNP, 0, lParam(@r));
   SetWindowRgn(Handle, rgn, True);
   Invalidate;
  end;
end;
{
//Forms e Edits
Procedure fHabilita;
var
  iFor : integer;
begin
//O Fcontabil e o FocusColor é atualizado no final desta procedure
  with Screen.ActiveForm do begin
    for iFor := 0 to ComponentCount-1 do begin
      if (Components[iFor] is TComboBox) then begin
        TComboBox(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TCheckListBox) then begin
        TCheckListBox(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TEdit) then begin
        TEdit(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TDateEdit) then begin
        TDateEdit(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TEvNumEdit) then begin
        TEvNumEdit(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TRxDBLookupCombo) then begin
        TRxDBLookupCombo(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TCurrencyEdit) then begin
        TCurrencyEdit(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TMaskEdit) then begin
        TMaskEdit(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TMemo) then begin
        TMaskEdit(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TCheckBox) then begin
        TCheckBox(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TFileNameEdit) then begin
        TFileNameEdit(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TDirectoryEdit) then begin
        TDirectoryEdit(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TDirectoryEdit) then begin
        TDirectoryEdit(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TRadioButton) then begin
        TRadioButton(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TBitBtn) then begin
        TBitBtn(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TSpeedButton) then begin
        TSpeedButton(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TEvDriveBox) then begin
        TEvDriveBox(Components[iFor]).Enabled := true;
      end;
    end;
  end;
end;
}

Procedure fHabilita(Form : TForm);
var
  iFor : integer;
begin
//O Fcontabil e o FocusColor é atualizado no final desta procedure
  with Form do begin
    for iFor := 0 to ComponentCount-1 do begin
      if (Components[iFor] is TComboBox) then begin
        TComboBox(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TCheckListBox) then begin
        TCheckListBox(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TEdit) then begin
        TEdit(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TDateEdit) then begin
        TDateEdit(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TEvDateEdit) then begin
        TEvDateEdit(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TEvMonthYear) then begin
        TEvMonthYear(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TEvNumEdit) then begin
        TEvNumEdit(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TRxDBLookupCombo) then begin
        TRxDBLookupCombo(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TDBLookupComboBox) then begin
        TDBLookupComboBox(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TCurrencyEdit) then begin
        TCurrencyEdit(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TMaskEdit) then begin
        TMaskEdit(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TMemo) then begin
        TMemo(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TCheckBox) then begin
        TCheckBox(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TFileNameEdit) then begin
        TFileNameEdit(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TDirectoryEdit) then begin
        TDirectoryEdit(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TRadioButton) then begin
        TRadioButton(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TRadioGroup) then begin
        TRadioGroup(Components[iFor]).Enabled := True;
      end else if (Components[iFor] is TBitBtn) then begin
        TBitBtn(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TSpeedButton) then begin
        TSpeedButton(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TEvDriveBox) then begin
        TEvDriveBox(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TDateTimePicker) then begin
        TDateTimePicker(Components[iFor]).Enabled := true;
      end else if (Components[iFor] is TEvCheckGroup ) then begin
        TEvCheckGroup(Components[iFor]).Enabled := true;
      end;
    end;
  end;
end;

//Procedure fDesabilita;
Procedure fDesabilita(Form: TForm);
var
  iFor : integer;
begin
//O Fcontabil e o FocusColor é atualizado no final desta procedure
//  with Screen.ActiveForm do begin
  with Form do begin
    for iFor := 0 to ComponentCount-1 do begin
      if (Components[iFor] is TComboBox ) then begin
        TComboBox(Components[iFor]).Enabled := false;
      end else if (Components[iFor] is TCheckListBox ) then begin
        TCheckListBox(Components[iFor]).Enabled := false;
      end else if (Components[iFor] is TEdit ) then begin
        TEdit(Components[iFor]).Enabled := false;
      end else if (Components[iFor] is TDateEdit ) then begin
        TDateEdit(Components[iFor]).Enabled := false;
      end else if (Components[iFor] is TEvDateEdit ) then begin
        TEvDateEdit(Components[iFor]).Enabled := false;
      end else if (Components[iFor] is TEvMonthYear ) then begin
        TEvMonthYear(Components[iFor]).Enabled := false;
      end else if (Components[iFor] is TEvNumEdit ) then begin
        TEvNumEdit(Components[iFor]).Enabled := false;
      end else if (Components[iFor] is TDBLookupComboBox ) then begin
        TDBLookupComboBox(Components[iFor]).Enabled := false;
      end else if (Components[iFor] is TRxDBLookupCombo ) then begin
        TRxDBLookupCombo(Components[iFor]).Enabled := false;
      end else if (Components[iFor] is TCurrencyEdit  ) then begin
        TCurrencyEdit(Components[iFor]).Enabled := false;
      end else if (Components[iFor] is TMaskEdit ) then begin
        TMaskEdit(Components[iFor]).Enabled := false;
      end else if (Components[iFor] is TMemo ) then begin
        TMemo(Components[iFor]).Enabled := false;
      end else if (Components[iFor] is TCheckBox ) then begin
        TCheckBox(Components[iFor]).Enabled := false;
      end else if (Components[iFor] is TFileNameEdit ) then begin
        TFileNameEdit(Components[iFor]).Enabled := false;
      end else if (Components[iFor] is TDirectoryEdit ) then begin
        TDirectoryEdit(Components[iFor]).Enabled := false;
      end else if (Components[iFor] is TRadioButton ) then begin
        TRadioButton(Components[iFor]).Enabled := false;
      end else if (Components[iFor] is TRadioGroup) then begin
        TRadioGroup(Components[iFor]).Enabled := false;
      end else if (Components[iFor] is TBitBtn ) then begin
        TBitBtn(Components[iFor]).Enabled := false;
      end else if (Components[iFor] is TSpeedButton) then begin
        TSpeedButton(Components[iFor]).Enabled := false;
      end else if (Components[iFor] is TEvDriveBox) then begin
        TEvDriveBox(Components[iFor]).Enabled := false;
      end else if (Components[iFor] is TDateTimePicker) then begin
        TDateTimePicker(Components[iFor]).Enabled := False;
      end else if (Components[iFor] is TEvCheckGroup ) then begin
        TEvCheckGroup(Components[iFor]).Enabled := false;
      end;
    end;
  end;
end;

Procedure LimpaEdits(Form: TForm; pbSoInabilitados: Boolean = False);
var
  liFor : Integer;
  PropInfo: PPropInfo; {Precisa da Unit TypInfo}
begin
  with Form do begin
    for liFor := 0 to ComponentCount -1 do begin
      if (Components[liFor] is TControl) then begin
        {Verifica se o componente tem a propriedade Enabled}
        PropInfo := GetPropInfo(Components[liFor].ClassInfo, 'Enabled');
        if (PropInfo <> nil) then begin
          {Só entra nesse if se tiver a propriedade Enabled}
          if (not pbSoInabilitados)
            or ((pbSoInabilitados) and (not TControl(Components[liFor]).Enabled))
          then begin
            {Só entra nesse if se o parâmetro pbSoInabilitados for False ou
            se ele for True e a propriedade Enabled do componente for False,
            ou seja, nesse caso só vai limpar se o componente estiver inabilitado}
            if Components[liFor] is TEdit then begin
              TEdit(Components[liFor]).Text := '';
            end else if Components[liFor] is TMaskEdit then begin
              TMaskEdit(Components[liFor]).Text := '';
            end else if Components[liFor] is TMemo then begin
              TMemo(Components[liFor]).Text := '';
            end else if Components[liFor] is TEvNumEdit then begin
              TEvNumEdit(Components[liFor]).Value := 0;
            end else if Components[liFor] is TDateEdit then begin
              TDateEdit(Components[liFor]).Date := 0;
            end else if Components[liFor] is TEvMonthYear then begin
              TEvMonthYear(Components[liFor]).DateValue := TP_DATA_EMPTY;
            end else if Components[liFor] is TEvDateEdit then begin
              TEvDateEdit(Components[liFor]).DateValue := TP_DATA_EMPTY;
            end else if Components[liFor] is TComboBox then begin
              TComboBox(Components[liFor]).ItemIndex := -1;
            end else if Components[liFor] is TRxDBLookupCombo then begin
              TRxDBLookupCombo(Components[liFor]).Value := '';
            end else if Components[liFor] is TDBLookupComboBox then begin
              TDBLookupComboBox(Components[liFor]).KeyValue := '';
            end else if Components[liFor] is TCheckBox then begin
              TCheckBox(Components[liFor]).Checked := false;
            end else if Components[liFor] is TDbText then begin
              TDbText(Components[liFor]).Caption := '';
//            end else if (Components[liFor] is TEvCheckGroup ) then begin
//              TEvCheckGroup(Components[liFor]).SetStates(0);
            end else if (Components[liFor] is TCheckBox) then begin
              TCheckBox(Components[liFor]).Checked := False;
            end;
          end;
        end;
      end;
    end;
  end;
end;

Procedure fPassaCampo(Sender: TObject; var key:Word);
begin
  with Screen.ActiveForm do begin
    if (Sender is TEvDateEdit) and (TEvDateEdit(Sender).SelStart = 10) then begin
      if trim(TEvDateEdit(Sender).Text) <> '' then begin
        Key:= 0;
        Perform(Wm_NextDlgCtl,0,0);
      end;
    end else if (Sender is TEdit) and (TEdit(Sender).SelStart = TEdit(Sender).MaxLength) then begin
      if trim(TEdit(Sender).Text) <> '' then begin
        Key:= 0;
        Perform(Wm_NextDlgCtl,0,0);
      end;
    end else if (Sender is TDateEdit) and (TDateEdit(Sender).SelStart = TDateEdit(Sender).MaxLength) then begin
      if ValidaData(TDateEdit(Sender)) then begin
        Key:= 0;
        Perform(Wm_NextDlgCtl,0,0);
      end;
    end else if (Sender is TMaskEdit) and (TMaskEdit(Sender).SelStart = TMaskEdit(Sender).MaxLength) then begin
      Key:= 0;
      Perform(Wm_NextDlgCtl,0,0);
    end;
  end;
end;

function fContaMask(sEstrutura:String):string;
begin
  rInfoAuxiliares.iPCGrauMax := 5;
//  FContabil.iGrauMax := 5;
  if sEstrutura = '9.9.9.99.999' then begin
    Result := '9\.9\.9\.99\.999;1';
    rInfoAuxiliares.sPCEstrutura := sEstrutura;
  end else if sEstrutura = '9.9.9.99.9999' then begin
    Result := '9\.9\.9\.99\.9999;1';
    rInfoAuxiliares.sPCEstrutura := sEstrutura;
  end else if sEstrutura = '9.9.9.999.999' then begin
    Result := '9\.9\.9\.999\.999;1';
    rInfoAuxiliares.sPCEstrutura := sEstrutura;
  end else if sEstrutura = '9.9.9.999.9999' then begin
    Result := '9\.9\.9\.999\.9999;1';
    rInfoAuxiliares.sPCEstrutura := sEstrutura;
  end else if sEstrutura = '9.9.9.9.9.99' then begin
    Result := '9\.9\.9\.9\.9\.99;1';
    rInfoAuxiliares.sPCEstrutura := sEstrutura;
    rInfoAuxiliares.iPCGrauMax := 6;
//    FContabil.iGrauMax := 6;
  end else begin
    Result := '9\.9\.9\.99\.999;1'; //Se não passar nenhuma estrutura conhecida, retorna a estrutura padrão.
    rInfoAuxiliares.sPCEstrutura := '9.9.9.99.999';
  end;
  rInfoAuxiliares.sPCMascara := Result;
end;

{Exemplo de uso:
ExecAndWait('c:\windows\notepad.exe', '', SW_SHOW);
Executar um programa e aguardar sua finalização antes de continuar
Inclua na seção uses: Windows}
function ExecAndWait(const FileName, Params: string; const WindowState: Word): boolean;
var
  SUInfo: TStartupInfo;
  ProcInfo: TProcessInformation;
  CmdLine: string;
begin
  { Coloca o nome do arquivo entre aspas. Isto é necessário devido aos espaços contidos em nomes longos }
//  CmdLine := '"' + trim(Filename) + '" "' + trim(Params) + '"';
  CmdLine := '"' + trim(Filename) + '" ' + trim(Params);
  FillChar(SUInfo, SizeOf(SUInfo), #0);
  with SUInfo do begin
    cb := SizeOf(SUInfo);
    dwFlags := STARTF_USESHOWWINDOW;
    wShowWindow := WindowState;
  end;
  Result := CreateProcess(nil, PChar(CmdLine), nil, nil, false,
  CREATE_NEW_CONSOLE + NORMAL_PRIORITY_CLASS, nil,
  PChar(ExtractFilePath(Filename)), SUInfo, ProcInfo);
  { Aguarda até ser finalizado }
  if Result then begin
    WaitForSingleObject(ProcInfo.hProcess, INFINITE);
    { Libera os Handles }
    CloseHandle(ProcInfo.hProcess);
    CloseHandle(ProcInfo.hThread);
  end;
end;

{*------------------------------------------------------------------------------
  Execute a complete shell command line and waits until terminated.

  @param CmdLine
  @param WindowState
  @return
  @source: http://www.swissdelphicenter.ch/torry/showcode.php?id=455
--------------------------------------------------------------------------------}
function ExecCmdLineAndWait(const CmdLine: string; WindowState: Word): Boolean;
var
  SUInfo: TStartupInfo;
  ProcInfo: TProcessInformation;
begin
  { Enclose filename in quotes to take care of long filenames with spaces. }
  FillChar(SUInfo, SizeOf(SUInfo), #0);
  with SUInfo do begin
    cb := SizeOf(SUInfo);
    dwFlags := STARTF_USESHOWWINDOW;
    wShowWindow := WindowState;
  end;
  Result := CreateProcess(
    nil,
    PChar(CmdLine),
    nil,
    nil,
    False,
    CREATE_NEW_CONSOLE or NORMAL_PRIORITY_CLASS,
    nil,
    nil, //PChar(ExtractFilePath(Filename))
    SUInfo,
    ProcInfo);
  //Wait for it to finish.
  if Result then begin
    WaitForSingleObject(ProcInfo.hProcess, INFINITE);
  end;
end;


{
http://www.activedelphi.com.br/modules.php?op=modload&name=News&file=article&sid=733&mode=thread&order=0&thold=0

Veja nesta dica como incrementar seu sistema acrescentando a validação do número eleitoral, com uma simples função desenvolvida baseando-se no Resolução do TSE.
Para entender como funciona o esquema de validação do título de eleitor devemos primeiro dar uma olhada na Resolução, de Nº 20.132 do dia 19/03/1998. Vejamos o que diz o artigo de número 10:
Art. 10 - Os Tribunais Regionais Eleitorais farão distribuir, observada a seqüência numérica fornecida pela Secretaria de Informática, às Zonas Eleitorais da respectiva Circunscrição, séries de números de inscrição eleitoral, a serem utilizados na forma deste artigo.
Parágrafo único - O número de inscrição compor-se-á de até 12 (doze) algarismos, por Unidade da Federação, assim discriminados:
a) os 8 (oito) primeiros algarismos serão seqüenciados, desprezando-se, na emissão, os zeros à esquerda;
b) os 2 (dois) algarismos seguintes serão representativos da Unidade da Federação de origem da inscrição, conforme códigos constantes da seguinte tabela:
01 - São Paulo
02 - Minas Gerais
03 - Rio de Janeiro
04 - Rio Grande do Sul
05 - Bahia
06 - Paraná
07 - Ceará
08 - Pernambuco
09 - Santa Catarina
10 - Goiás
11 - Maranhão
12 - Paraíba
13 - Pará
14 - Espírito Santo
15 - Piauí
16 - Rio Grande do Norte
17 - Alagoas
18 - Mato Grosso
19 - Mato Grosso do Sul
20 - Distrito Federal
21 - Sergipe
22 - Amazonas
23 - Rondônia
24 - Acre
25 - Amapá
26 - Roraima
27 - Tocantins
28 - Exterior (ZZ)
c) os 2 (dois) últimos algarismos constituirão dígitos verificadores, determinados com base no módulo 11 (onze), sendo o primeiro calculado sobre o número seqüencial e o último sobre o código da Unidade da Federação seguido do primeiro dígito verificador.
Resumindo: Os dígitos verificadores são calculados em duas etapas. Na primeira, calcula-se o módulo 11 sobre os 8 primeiros dígitos. Os estados de SP e MG possuem títulos com 13 dígitos, sendo assim, nestes casos devemos considerar os 9 primeiros algarismos. Na segunda etapa calculamos o módulo 11 sobre o código da UF + o primeiro dígito verificador.
}

function CheckTituloEleitor(numero: String): Boolean;
var
  intInd1,intInd2,intLimite    : Integer;
  intSoma,intDigito            : Integer;
  strDVc,strSequencial         : String;
  strUF,strDV1,strDV2          : String;
begin
  numero := Trim(numero);
  while (Length(numero) < 13) do begin
    numero := '0' + numero;
  end;
  intInd1 := 0;
  intInd2 := 0;
  strDVc  := '';
  strSequencial := Copy(numero,1,9);
  strUF         := Copy(numero,10,2);
  strDV1        := Copy(numero,12,1);
  strDV2        := Copy(numero,13,1);
  {Verifca se a UF estiver entre os código possíveis, de 1(SP) até 28(ZZ-Exterior)}
  if ((StrToInt(strUF) >  0) and (StrToInt(strUF) < 29)) then begin
    intLimite := 9;
    {Loop para calcular os 2 dígitos verificadores}
    for intInd1 := 1 to 2 do begin
      intSoma := 0;
      {Calcula a soma para submeter ao módulo 11}
      for intInd2 := 1 to intLimite do begin
       intSoma := intSoma + StrToInt(Copy(strSequencial,intInd2,1)) * (intLimite + 2 - intInd2);
      end;
      {Pega o resto da dívisão, o módulo, por 11}
      intDigito := intSoma mod 11;
      { Se a UF for SP ou MG}
      if  (StrToInt(strUF) in [1,2]) then begin
        if (intDigito = 1) then begin
          intDigito := 0
        end else if (intDigito = 0) then begin
          intDigito := 1
        end else begin
          intDigito := 11 - intDigito;
        end;
      end else begin
        {Outros UF e Exterior}
        if ((intDigito = 1) or (intDigito = 0)) then begin
          intDigito := 0
        end else begin
          intDigito := 11 - intDigito;
        end;
      end;
      {Atribui à variavel strDVc o dígito calculado}
      strDVc := strDVc + IntToStr(intDigito);
      {Muda o valor de intLimite para o cáculo do segundo dígito}
      intLimite:= 3;
      {O cálculo do segundo dígito será sobre o código da UF + primeiro dígito verificador}
      strSequencial:= strUF + IntToStr(intDigito);
    end;
  end;
  result := (strDV1+strDV2 = strDVc);
end;

procedure RdRodape(iLinha,iCol,iTamTraco:integer; psId: string = ''; pbImprimeData: Boolean = True);
var
  iFor : integer;
begin
  inc(iLinha);
  if Screen.ActiveForm <> nil then begin
    if Trim(psId) <> '' then begin
      psId := StrSubst(psId,'{','',0);
      psId := StrSubst(psId,'}','',0);
      psId := 'ID: '+psId;
    end;

//    {$IFDEF VER230}
    with Screen.ActiveForm do begin
      for iFor := 0 to ComponentCount-1 do begin
        if Components[iFor] is TRDPrint then begin
          TRDPrint(Components[iFor]).LinhaH(iLinha,iCol,iTamTraco,0,true);
          inc(iLinha);
          TRDPrint(Components[iFor]).impf(iLinha,iCol+1,rInfoEmpresa.sNome,[comp17,italico]);
          TRDPrint(Components[iFor]).impf(iLinha,iTamTraco-17,rInfoEmpresa.sHomePage,[comp17]);
          inc(iLinha);
          TRDPrint(Components[iFor]).impf(iLinha,iCol+1,psId,[comp17,italico]);
          if pbImprimeData then begin
            TRDPrint(Components[iFor]).impf(iLinha,iTamTraco-13,DateToStr(Date())+' '+TimeToStr(Time()),[comp17]);
          end;
        end;
      end;
    end;
//   {$ENDIF}
  end;
end;

procedure AtualizaStatusBar(var postBar: TStatusBar; psVersao: String;
  pdDataOperacao,pdDataInicio: TDate; pdAtualizaDatas: Boolean = True);
var
  lsData,lsPrograma: String;
begin
  postBar.Font.Size := 8;
  postBar.Font.Color := clTeal;

  postBar.Panels[0].style := psText;
//  stBar.Panels[0].width := (length('USUÁRIO: '+rInfoLogin.sNomeUsuario)+10)*5;
//  stBar.Panels[0].Text := 'USUÁRIO: '+rInfoLogin.sNomeUsuario;
//  if (CompareStr(getEnvironmentVariable('WS_LOGIN'),'ATIVO') = 0) then begin
  if TUtil.getUsaUserControl(rInfoAplicacao.iSerial) then begin
    postBar.Panels[0].width := (length('USUÁRIO: '+rInfoLogin.sNomeUsuario)+10)*5;
    postBar.Panels[0].Text := 'USUÁRIO: '+rInfoLogin.sNomeUsuario;
  end else begin
    postBar.Panels[0].width := (length('USUÁRIO: master')+10)*5;
    postBar.Panels[0].Text := 'USUÁRIO: master';
  end;

  postBar.Panels[1].style := psText;
  postBar.Panels[1].width := (length('Versão: '+psVersao)+10)*5;
  postBar.Panels[1].Text := 'Versão: '+psVersao;

  postBar.Panels[2].style := psText;
  postBar.Panels[2].width := 450;
  postBar.Panels[2].Text := TUtil.getStrCodigoPessoa+'-'+Copy(TUtil.GetNomePessoa,1,70)+' '+TUtil.getTipoInscMfPessoa+': '+TUtil.getInscMfPessoa;

  if pdAtualizaDatas then begin
    lsPrograma := UpperCase(ExtractFileName(Application.ExeName));
    if (lsPrograma = 'MEGAPESSOAL.EXE') or (lsPrograma = 'MEGAFISCAL.EXE') then begin
      if pdDataOperacao <> TP_DATA_EMPTY then begin
        lsData := 'Mês/Ano: '+MesAno(pdDataOperacao,true);
      end else begin
        if (lsPrograma = 'MEGAFISCAL.EXE') and (pdDataInicio >= TP_DATA_INICIAL) then begin
          lsData := 'Mês/Ano: '+MesAno(pdDataInicio,true);
        end else begin
          lsData := '';
        end;
      end;
    end else if (lsPrograma = 'MEGACONTABIL.EXE') then begin
      lsData := 'Ano: '+StrZero(year(pdDataOperacao),4,0);
    end;
    postBar.Panels[3].style := psText;
    postBar.Panels[3].width := (length(lsData)+10)*5;
    postBar.Panels[3].Text  := lsData;

    if (pdDataInicio <> TP_DATA_EMPTY) then begin
      if (pdDataInicio >= TP_DATA_INICIAL) then begin
        lsData := 'Data de Início: '+DateToStr(pdDataInicio);
      end else begin
        lsData := 'Data de Início: '+DateToStr(BeginOfMonth(Date()));
      end;
    end;

    postBar.Panels[4].style := psText;
    postBar.Panels[4].width := (length(lsData)+10)*5;
    postBar.Panels[4].Text  := lsData;
  end;
end;

function BooleanToInt(pbBoolean: Boolean): Integer;
begin
  Result := pbBoolean.ToInteger;
end;

function IntToBoolean(piInteger: Integer): Boolean;
begin
  Result := piInteger.ToBoolean;
end;

function DecimalToRomano( piDecimal: LongInt ): String;
const
  Romans: Array[1..13] of String = ( 'I', 'IV', 'V', 'IX', 'X', 'XL', 'L',
  'XC', 'C', 'CD', 'D', 'CM', 'M' );
  Arabics: Array[1..13] of Integer =( 1, 4, 5, 9, 10, 40, 50, 90, 100,
  400, 500, 900, 1000);
var
  liFor: Integer;
  lsCratch: String;
begin
  lsCratch := '';
  for liFor := 13 downto 1 do begin
    while ( piDecimal >= Arabics[liFor] ) do begin
      piDecimal := piDecimal - Arabics[liFor];
      lsCratch := lsCratch + Romans[liFor];
    end;
  end;
  Result := lsCratch;
end;

function IncValue(var value: Integer; piIncremento: Integer = 1): Integer;
begin
  inc(value,piIncremento);
  Result := value;
end;

function IncLongWord(var value: LongWord): LongWord;
begin
  value := value+1;
  Result := value;
end;

function fEnderecoPessoa(poCdsPessoa: TClientDataSet; pTamanhoLinha: Integer): String;
  function ConcatenaEndereco(poCdsPessoa: TClientDataSet; pAbreviaLogradouro: Boolean): String;
  begin
    if Result <> '' then begin
      Result := Result+' ';
    end;
    if pAbreviaLogradouro then begin
      Result := Result+AbreviaNome(poCdsPessoa.FieldByName('LOGRADOURO').AsString);
    end else begin
      Result := Result+poCdsPessoa.FieldByName('LOGRADOURO').AsString;
    end;
    if poCdsPessoa.FieldByName('NUMERO').AsString <> '' then begin
      Result := Result+', '+poCdsPessoa.FieldByName('NUMERO').AsString;
    end;
    if poCdsPessoa.FieldByName('COMPLEMENTO').AsString <> '' then begin
      Result := Result+', '+poCdsPessoa.FieldByName('COMPLEMENTO').AsString;
    end;
    Result := Result+', '+poCdsPessoa.FieldByName('CIDADE').AsString+'-'+poCdsPessoa.FieldByName('ESTADO').AsString;
    Result := Result+', '+poCdsPessoa.FieldByName('CEP').AsString;
  end;
begin
  Result := '';
  {Concatena o endereço sem abreviar}
  Result := ConcatenaEndereco(poCdsPessoa,false);
  if length(Result) > pTamanhoLinha then begin
    {Se o endereço ficar maior que o tamanho da linha, concatena o endereço
     abreviando os nomes do meio da descrição do logradouro. Ex: Rua André
     Luis Ribeiro da Fonte, retorna Rua André L. R. da Fonte}
    Result := ConcatenaEndereco(poCdsPessoa,true);
  end;
end;

procedure OrdenaDataSetGrid(
  var CDS: TClientDataSet; Column: TColumn; var dbgPrin: TDBGrid);
const
  idxDefault = 'DEFAULT_ORDER';
var
  strColumn : string;
  i : integer;
  bolUsed : boolean;
  idOptions : TIndexOptions;
begin

  strColumn := idxDefault;

  if Column.Field.FieldKind in [fkCalculated, fkLookup, fkAggregate] then begin
    Exit;
  end;

  if Column.Field.DataType in [ftBlob, ftMemo] then begin
    Exit;
  end;

  for i := 0 to dbgPrin.Columns.Count -1 do begin
    dbgPrin.Columns[i].Title.Font.Style := [];
  end;

  bolUsed := (Column.Field.FieldName = CDS.IndexName);

  CDS.IndexDefs.Update;
  for i := 0 to CDS.IndexDefs.Count - 1 do begin
    if CDS.IndexDefs.Items[i].Name = Column.Field.FieldName then begin
      strColumn := Column.Field.FieldName;
      case (CDS.IndexDefs.Items[i].Options = [ixDescending]) of
        true : idOptions := [];
        false : idOptions := [ixDescending];
      end;
    end;
  end;

  if (strColumn = idxDefault)  or (bolUsed) then begin
    if bolUsed then begin
      CDS.DeleteIndex(Column.Field.FieldName);
    end;

    try
      CDS.AddIndex(Column.Field.FieldName, Column.Field.FieldName, idOptions, '', '', 0);
      strColumn := Column.Field.FieldName;
    except
      if bolUsed then begin
        strColumn := idxDefault;
      end;
    end;
  end;

  try
   CDS.IndexName := strColumn;
   Column.Title.Font.Style := [fsbold];
  except
   CDS.IndexName := idxDefault;
  end;
end;

function IsInternetConected(): Boolean;
const
  Key = '\System\CurrentControlSet\Services\RemoteAccess';
  Value = 'Remote Connection';
var
  Reg: TRegistry; {Unit Registry.pas}
  Buffer: DWord;
begin
  Result := false;

  Reg := TRegistry.Create;
  try
    Reg.RootKey := HKEY_LOCAL_MACHINE;
    if Reg.OpenKey(Key, false) then
    begin
      Reg.ReadBinaryData(Value, Buffer, SizeOf(Buffer));
      Result := Buffer = 1;
    end;
  finally
    Reg.CloseKey;
    Reg.Free;
  end;
end;
end.

